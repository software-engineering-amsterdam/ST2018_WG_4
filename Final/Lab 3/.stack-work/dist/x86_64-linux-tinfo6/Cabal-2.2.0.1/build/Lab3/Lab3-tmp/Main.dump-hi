
==================== FINAL INTERFACE ====================
2018-09-25 21:39:37.793592063 UTC

interface main:Main 8043
  interface hash: 577e676ba9034b274d090a781b3feb44
  ABI hash: 20e864c107fc83bb9d77f012e4eb1b7b
  export-list hash: 9044a7950e0c3f2ce15bc231fb125fe1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 8685d694e67a748160b24bb5044d3233
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.altCnfProbe
  Main.applyDeMorganLaw
  Main.applyDistributiveLaw
  Main.checkTestResult
  Main.chooseRandomProperty
  Main.chooseRandomSplitForm
  Main.cnf
  Main.cnf2cls
  Main.cnfProbe
  Main.cnfTest
  Main.contradiction
  Main.convertPropToClause
  Main.convertToCNF
  Main.dnf
  Main.dnfProbe
  Main.doRandomlyNegate
  Main.entails
  Main.equiv
  Main.falseEvals
  Main.formToCls
  Main.generateActualForm
  Main.generateForm
  Main.generateFormList
  Main.getAsList
  Main.getCurRand
  Main.getCurRandNum
  Main.isCnf
  Main.isConjunction
  Main.isDisjunction
  Main.isDnf
  Main.isLiteral
  Main.main
  Main.maxFormDepth
  Main.negAtoms
  Main.negDigs
  Main.negateLiteral
  Main.none
  Main.numAtoms
  Main.numDigs
  Main.optimizeOR
  Main.pAndNotP
  Main.pAndQ
  Main.pOrNotP
  Main.pOrQ
  Main.parserTest
  Main.propNumAtoms
  Main.propNumNegs
  Main.randomNumberStream
  Main.removeDuplicates
  Main.tautology
  Main.testFormProperty
  Main.treeStateListToTreeState
  Main.trueEvals
  Main.truthTable
  Main.valuationToCnjClause
  Main.valuationToDsjClause
  Main.Clause
  Main.Clauses
  Main.TreeState{Main.TreeState amountOfProperties curRand form}
module dependencies: Lecture3
package dependencies: QuickCheck-2.11.3 array-0.5.2.0 base-4.11.1.0
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 pretty-1.1.3.6
                      primitive-0.6.3.0 random-1.1 template-haskell-2.13.0.0
                      tf-random-0.5 time-1.8.0.2 transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.11.3:Test.QuickCheck e00d138ee3234e83a31cc3113c8c8ffb
import  -/  base-4.11.1.0:Data.Char 3e89818e2b8ef1a2cc5393163484da72
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Enum 8824828888f5a89ecc9e7c73f05f3151
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  base-4.11.1.0:System.IO.Unsafe 0a2eb33ad4988fdd87ebf1fb8b419957
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  Lecture3 e7aa3775536d61807663859841e34829
  exports: 9ddcc891a5d1fbc8e3c36d7ebeeced72
  --> 9d8f2d04dcda7a24feb588679ecfebe1
  Cnj 9c2c481db6e2ec045ea868407cbb0ca4
  Dsj b4099d33bb7b2192fe92514d26bd459f
  Equiv 7703af904cd7b14a8d4aa3e6e50cafcc
  Form f1017ddd98abe9802319d139ccdb1a45
  Impl b5b6c91b8f55fe64dec2176918b5a6ab
  Neg 4ef3569eac125224ca98a9b34751ca1e
  Prop b39bfa9279852cfcff515dde39a0396b
  Valuation 3f07eeb77d0f3a113a6d781cc9da7a0f
  allVals 07371b0b3f53190327a90111c6d431c1
  evl aea88ee9570620816adf506e66a1d266
  p 54238374b6ad94e59436d9203e9bf31d
  parse 34236f750c6e5fd67c1582e5f1be6eb9
  q ecb1ea6ecdc5b441c9806517ea4f59d9
  while f56fdf22e21e9458034999fa700f2139
import  -/  random-1.1:System.Random 31994b60c33f032d578c64a928f735f7
a541b2ebdb613c6ae2ad5660f975e423
  $tc'TreeState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11161068614268354794##
                   5968605264523984341##
                   Main.$trModule
                   Main.$tc'TreeState2
                   0#
                   Main.$tc'TreeState1) -}
75fadebd9dd0eeaa36c6520061bc117d
  $tc'TreeState1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
64abc41d12ba6a1836ba275c9897dc74
  $tc'TreeState2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'TreeState3) -}
7cc68869da5e896f79d62a4d53ad33eb
  $tc'TreeState3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'TreeState"#) -}
46e03f073b5c6a0099b7a1697de35526
  $tcTreeState :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2763301081759400247##
                   10884153590940357408##
                   Main.$trModule
                   Main.$tcTreeState1
                   0#
                   GHC.Types.krep$*) -}
109de17b0849fe5907a3f845ce56ceb2
  $tcTreeState1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTreeState2) -}
31e00dd9b5f8ae8f627ceeccb739c73b
  $tcTreeState2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TreeState"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
2751d6c831988d196fe3dc998a7ceb0b
  $waltCnfProbe ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
64f336c2d2ad4ea4a7ba1b732d77c543
  $wchooseRandomProperty ::
    [GHC.Types.Float]
    -> Main.TreeState
    -> (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #)
  {- Arity: 2, Strictness: <L,1*U><L,U(1*U(U),A,U(U))>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Float]) (w1 :: Main.TreeState) ->
                 let {
                   props :: GHC.Types.Int
                   = case w1 of wild { Main.TreeState ds ds1 ds2 -> ds }
                 } in
                 let {
                   chosenProperty :: GHC.Types.Int
                   = case w1 of wild { Main.TreeState ds ds1 ds2 ->
                     case ds2 of ww { GHC.Types.I# ww1 ->
                     case GHC.List.$w!!
                            @ GHC.Types.Float
                            w
                            ww1 of wild1 { GHC.Types.F# x ->
                     case props of wild2 { GHC.Types.I# x1 ->
                     let {
                       x2 :: GHC.Prim.Float#
                       = GHC.Prim.timesFloat# x (GHC.Prim.int2Float# (GHC.Prim.+# x1 1#))
                     } in
                     let {
                       n :: GHC.Prim.Int# = GHC.Prim.float2Int# x2
                     } in
                     case GHC.Prim.ltFloat# x2 (GHC.Prim.int2Float# n) of lwild {
                       DEFAULT -> GHC.Types.I# n
                       1# -> GHC.Types.I# (GHC.Prim.-# n 1#) } } } } }
                 } in
                 (# case chosenProperty of wild { GHC.Types.I# x ->
                    case props of wild1 { GHC.Types.I# y ->
                    case GHC.Prim.==# x y of lwild {
                      DEFAULT -> wild1 1# -> GHC.Types.I# (GHC.Prim.+# y 1#) } } },
                    Lecture3.Prop chosenProperty,
                    case w1 of wild { Main.TreeState ds ds1 ds2 ->
                    case ds2 of wild1 { GHC.Types.I# x ->
                    GHC.Types.I# (GHC.Prim.+# x 1#) } } #)) -}
99cc60380eb08e8bd50b25cc2e1ef037
  $wchooseRandomSplitForm ::
    [GHC.Types.Float]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #)
  {- Arity: 4, Strictness: <S,U><L,U(U)><L,U(U)><S,U>, Inline: [0] -}
91a7e38d963ff7c448b28f8fdc5277d5
  $wcnfProbe ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
221198f0bea42d1e7cf2c3c2dc53bb11
  $wcnfTest ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
86c6d8da96ca283293ed5769ad763b8e
  $wdnfProbe ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
0543167fb8b14893919e8705a470089a
  $wdoRandomlyNegate ::
    [GHC.Types.Float]
    -> Main.TreeState
    -> (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #)
  {- Arity: 2, Strictness: <L,1*U><L,U(1*U,U,U(U))>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Float]) (w1 :: Main.TreeState) ->
                 (# case w1 of wild { Main.TreeState ds ds1 ds2 -> ds },
                    case w1 of wild { Main.TreeState ds ds1 ds2 ->
                    case ds2 of ww { GHC.Types.I# ww1 ->
                    case GHC.List.$w!!
                           @ GHC.Types.Float
                           w
                           ww1 of wild1 { GHC.Types.F# x ->
                    let {
                      x1 :: GHC.Prim.Float# = GHC.Prim.plusFloat# x x
                    } in
                    let {
                      n :: GHC.Prim.Int# = GHC.Prim.float2Int# x1
                    } in
                    case GHC.Prim.ltFloat# x1 (GHC.Prim.int2Float# n) of lwild {
                      DEFAULT
                      -> case n of wild2 { DEFAULT -> ds1 0# -> Lecture3.Neg ds1 }
                      1#
                      -> case n of lwild1 {
                           DEFAULT -> ds1 1# -> Lecture3.Neg ds1 } } } } },
                    case w1 of wild { Main.TreeState ds ds1 ds2 ->
                    case ds2 of wild1 { GHC.Types.I# x ->
                    GHC.Types.I# (GHC.Prim.+# x 1#) } } #)) -}
66ba5bffdf7a61196290349ac5b9571b
  $wgenerateForm ::
    [GHC.Types.Float]
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #)
  {- Arity: 4, Strictness: <S,U><S,U><L,U(U)><S,U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Float])
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#) ->
                 case GHC.List.$w!!
                        @ GHC.Types.Float
                        w
                        ww2 of wild { GHC.Types.F# x ->
                 let {
                   x1 :: GHC.Prim.Float# = GHC.Prim.timesFloat# x 7.0#
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.float2Int# x1
                 } in
                 let {
                   newState :: GHC.Prim.Int# = GHC.Prim.+# ww2 1#
                 } in
                 let {
                   $j :: (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #) <join 0>
                   = let {
                       chosenProperty :: GHC.Types.Int
                       = case GHC.List.$w!!
                                @ GHC.Types.Float
                                w
                                newState of wild1 { GHC.Types.F# x2 ->
                         case ww1 of wild2 { GHC.Types.I# x3 ->
                         let {
                           x4 :: GHC.Prim.Float#
                           = GHC.Prim.timesFloat# x2 (GHC.Prim.int2Float# (GHC.Prim.+# x3 1#))
                         } in
                         let {
                           n1 :: GHC.Prim.Int# = GHC.Prim.float2Int# x4
                         } in
                         case GHC.Prim.ltFloat# x4 (GHC.Prim.int2Float# n1) of lwild {
                           DEFAULT -> GHC.Types.I# n1
                           1# -> GHC.Types.I# (GHC.Prim.-# n1 1#) } } }
                     } in
                     let {
                       state :: GHC.Prim.Int# = GHC.Prim.+# newState 1#
                     } in
                     (# case chosenProperty of wild1 { GHC.Types.I# x2 ->
                        case ww1 of wild2 { GHC.Types.I# y ->
                        case GHC.Prim.==# x2 y of lwild {
                          DEFAULT -> wild2 1# -> GHC.Types.I# (GHC.Prim.+# y 1#) } } },
                        case GHC.List.$w!!
                               @ GHC.Types.Float
                               w
                               state of wild1 { GHC.Types.F# x2 ->
                        let {
                          x3 :: GHC.Prim.Float# = GHC.Prim.plusFloat# x2 x2
                        } in
                        let {
                          n1 :: GHC.Prim.Int# = GHC.Prim.float2Int# x3
                        } in
                        case GHC.Prim.ltFloat# x3 (GHC.Prim.int2Float# n1) of lwild {
                          DEFAULT
                          -> case n1 of wild2 {
                               DEFAULT -> Lecture3.Prop chosenProperty
                               0# -> Lecture3.Neg (Lecture3.Prop chosenProperty) }
                          1#
                          -> case n1 of lwild1 {
                               DEFAULT -> Lecture3.Prop chosenProperty
                               1# -> Lecture3.Neg (Lecture3.Prop chosenProperty) } } },
                        GHC.Types.I# (GHC.Prim.+# state 1#) #)
                 } in
                 let {
                   $j1 :: (# GHC.Types.Int, Lecture3.Form, GHC.Types.Int #) <join 0>
                   = Main.$wdoRandomlyNegate
                       w
                       (case Main.$wchooseRandomSplitForm
                               w
                               (GHC.Types.I# (GHC.Prim.-# ww 1#))
                               ww1
                               newState of ww3 { (#,,#) ww4 ww5 ww6 ->
                        Main.TreeState ww4 ww5 ww6 })
                 } in
                 case GHC.Prim.ltFloat# x1 (GHC.Prim.int2Float# n) of lwild {
                   DEFAULT
                   -> case GHC.Prim.<# n ww of lwild1 { DEFAULT -> $j 1# -> $j1 }
                   1#
                   -> case GHC.Prim.<# (GHC.Prim.-# n 1#) ww of lwild1 {
                        DEFAULT -> $j 1# -> $j1 } } }) -}
b64977cf0096bfcbf0ee8522987927ea
  $wgenerateFormList ::
    [GHC.Types.Float]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> [Main.TreeState]
    -> [Main.TreeState]
  {- Arity: 5, Strictness: <S,U><L,U(U)><L,U(U)><S,U><L,U>,
     Inline: [0] -}
f6c24ce2da7dbdf7c9bc11635625354e
  $wnegDigs :: Main.Clauses -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
ad930c163add7e0da155c7975f72c20e
  $wnumAtoms :: Lecture3.Form -> GHC.Types.Int -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>,
     Inline: [0] -}
73d8af33db5b2ca689f57705c3763fd0
  $wnumDigs :: Main.Clauses -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
2c242656ab626102749dfe0ba7317f38
  $wparserTest ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0] -}
6b8ee49cbea213ccffd6fbb3493eca75
  $wtestFormProperty ::
    (Lecture3.Form -> GHC.Types.Bool)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,1*C1(U)><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: Lecture3.Form -> GHC.Types.Bool)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.Prim.==# ww ww1 of lwild {
                   DEFAULT
                   -> case System.Random.theStdGen
                             `cast`
                           (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                      case GHC.Prim.atomicModifyMutVar#
                             @ GHC.Prim.RealWorld
                             @ System.Random.StdGen
                             @ (System.Random.StdGen, System.Random.StdGen)
                             @ System.Random.StdGen
                             r#
                             System.Random.newStdGen2
                             w1 of ds1 { (#,#) ipv ipv1 ->
                      case ipv1 of b1 { System.Random.StdGen ipv2 ipv3 ->
                      let {
                        ipv4 :: Lecture3.Form
                        = case Main.$wgenerateForm
                                 (Main.generateActualForm_go b1)
                                 6#
                                 Main.generateActualForm2
                                 0# of ww2 { (#,,#) ww3 ww4 ww5 ->
                          ww4 }
                      } in
                      case w ipv4 of wild1 {
                        GHC.Types.False
                        -> case Main.testFormProperty6 ipv4
                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
                           of {}
                        GHC.Types.True
                        -> case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  (GHC.CString.unpackAppendCString#
                                     Main.testFormProperty5
                                     (Lecture3.$fShowForm_$cshow ipv4))
                                  GHC.Types.True
                                  ipv of ds2 { (#,#) ipv5 ipv6 ->
                           Main.$wparserTest (GHC.Prim.+# ww 1#) ww1 ipv5 } } } } }
                   1#
                   -> GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           Main.testFormProperty4
                           (case GHC.Show.$wshowSignedInt
                                   0#
                                   ww1
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Base.++_$s++
                              @ GHC.Types.Char
                              Main.testFormProperty2
                              ww5
                              ww6 }))
                        GHC.Types.True
                        w1 }) -}
88dee24b2abe3bea071ee4cfb5a222ea
  type Clause = [GHC.Types.Int]
b431ff5bc52d7e80c349ed5d54659373
  type Clauses = [Main.Clause]
69fb7f569e0fbbf5cbb92276f8765ab1
  data TreeState
    = TreeState {amountOfProperties :: GHC.Types.Int,
                 form :: Lecture3.Form,
                 curRand :: GHC.Types.Int}
4f990fb7c41c644739db1572bd761e52
  altCnfProbe :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.altCnfProbe1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
02487e55fee96c8d482a6670bea370f5
  altCnfProbe1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$waltCnfProbe ww1 ww3 w2 } }) -}
69fb7f569e0fbbf5cbb92276f8765ab1
  amountOfProperties :: Main.TreeState -> GHC.Types.Int
  RecSel Left Main.TreeState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.TreeState) ->
                 case ds of wild { Main.TreeState ds1 ds2 ds3 -> ds1 }) -}
e903af85078a1b4e3d3afbf228eeca46
  applyDeMorganLaw :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6aab14427fa11da3ede2c4d7058e0299
  applyDistributiveLaw :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ab87e2bb5ba70cc6754c8e77034b9c63
  checkTestResult :: GHC.Types.Bool -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Bool) ->
                 case ds of wild {
                   GHC.Types.False -> Main.checkTestResult3
                   GHC.Types.True -> Main.checkTestResult1 }) -}
ba02eb31bc683fefc3af5b3b0d6755f2
  checkTestResult1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.checkTestResult2) -}
434443e4fa09b62f21dec719380f87f1
  checkTestResult2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\ESC[32mTest succeeded!\ESC[0m"#) -}
ef9ca2e7c68c30e1a7f88aac6829fc90
  checkTestResult3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.checkTestResult4) -}
4510ad5bdc66b32f0bbaa0b64274861f
  checkTestResult4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\ESC[31mTest failed!\ESC[0m"#) -}
925f3e946cbc9bb83b16786b885c66d7
  chooseRandomProperty ::
    [GHC.Types.Float] -> Main.TreeState -> Main.TreeState
  {- Arity: 2, Strictness: <L,1*U><L,U(U(U),A,U(U))>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Types.Float]) (w1 :: Main.TreeState) ->
                 case Main.$wchooseRandomProperty w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 Main.TreeState ww1 ww2 ww3 }) -}
b9251b45396175bbb6251f12f87a1598
  chooseRandomSplitForm ::
    [GHC.Types.Float]
    -> GHC.Types.Int -> Main.TreeState -> Main.TreeState
  {- Arity: 3,
     Strictness: <S,U><L,U(U)><S(LLS(S)),1*U(U(U),A,1*U(U))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Float])
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.TreeState) ->
                 case w2 of ww { Main.TreeState ww1 ww2 ww3 ->
                 case ww3 of ww4 { GHC.Types.I# ww5 ->
                 case Main.$wchooseRandomSplitForm
                        w
                        w1
                        ww1
                        ww5 of ww6 { (#,,#) ww7 ww8 ww9 ->
                 Main.TreeState ww7 ww8 ww9 } } }) -}
8f5f886f94417b3b4199ba359229b542
  cnf :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, Strictness: <L,U>m3,
     Unfolding: InlineRule (1, True, False)
                (\ (f :: Lecture3.Form) ->
                 Lecture3.Cnj
                   (GHC.Base.build
                      @ Lecture3.Form
                      (\ @ b1
                         (c :: Lecture3.Form -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [(Lecture3.Name, GHC.Types.Bool)]
                         @ b1
                         (GHC.Base.mapFB
                            @ Lecture3.Form
                            @ b1
                            @ [(Lecture3.Name, GHC.Types.Bool)]
                            c
                            Main.valuationToDsjClause)
                         n
                         (Main.falseEvals f)))) -}
a7b0417bdd1dc1ce71eb30ef307e2e82
  cnf2cls :: Lecture3.Form -> Main.Clauses
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.:
                        @ Main.Clause
                        (case wild of wild1 {
                           DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                           Lecture3.Prop ds1
                           -> case ds1 of wild2 { GHC.Types.I# ds2 ->
                              case ds2 of ds3 {
                                DEFAULT
                                -> GHC.Types.: @ GHC.Types.Int wild2 (GHC.Types.[] @ GHC.Types.Int)
                                0# -> Main.cnf2cls4 } }
                           Lecture3.Neg ds1
                           -> case ds1 of wild2 {
                                DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                                Lecture3.Prop ds2
                                -> case ds2 of wild3 { GHC.Types.I# ds3 ->
                                   case ds3 of ds4 {
                                     DEFAULT
                                     -> GHC.Types.:
                                          @ GHC.Types.Int
                                          (GHC.Types.I# (GHC.Prim.negateInt# ds4))
                                          (GHC.Types.[] @ GHC.Types.Int)
                                     0# -> Main.cnf2cls2 } } } })
                        (GHC.Types.[] @ Main.Clause)
                   Lecture3.Cnj fs
                   -> GHC.Base.map @ Lecture3.Form @ [GHC.Types.Int] Main.cnf2cls1 fs
                   Lecture3.Dsj fs
                   -> GHC.Types.:
                        @ Main.Clause
                        (Main.cnf2cls_go fs)
                        (GHC.Types.[] @ Main.Clause) }) -}
711d809468cfc7856c979e5ae38876df
  cnf2cls1 :: Lecture3.Form -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Lecture3.Form) ->
                 case x of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                   Lecture3.Prop ds
                   -> case ds of wild1 { GHC.Types.I# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> GHC.Types.: @ GHC.Types.Int wild1 (GHC.Types.[] @ GHC.Types.Int)
                        0# -> Main.cnf2cls4 } }
                   Lecture3.Neg ds
                   -> case ds of wild1 {
                        DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                        Lecture3.Prop ds1
                        -> case ds1 of wild2 { GHC.Types.I# ds2 ->
                           case ds2 of ds3 {
                             DEFAULT
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I# (GHC.Prim.negateInt# ds3))
                                  (GHC.Types.[] @ GHC.Types.Int)
                             0# -> Main.cnf2cls2 } } }
                   Lecture3.Cnj x1 -> Main.cnf2cls_go x1
                   Lecture3.Dsj x1 -> Main.cnf2cls_go x1 }) -}
2477780804a475a22a3b4b7fa3cc88f5
  cnf2cls2 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   Main.cnf2cls3
                   (GHC.Types.[] @ GHC.Types.Int)) -}
0d145266035eddec51b92043a3b0f191
  cnf2cls3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.I# -9223372036854775807#) -}
66650886033822529f30ee7080502d24
  cnf2cls4 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   GHC.Base.maxInt
                   (GHC.Types.[] @ GHC.Types.Int)) -}
87f8e43e8bcea6dd39fca85ec4ebff3d
  cnf2cls_go :: [Lecture3.Form] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f144ec09d0d7395d742920c89144ee46
  cnfProbe :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.cnfProbe1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
6f46fcdf3f53d1d59304d1a181912153
  cnfProbe1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wcnfProbe ww1 ww3 w2 } }) -}
d47b04b9d6afc0f630611b0c6fa89340
  cnfTest :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.cnfTest1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
007f08c29cfe72cc5a17e52d68721d5f
  cnfTest1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wcnfTest ww1 ww3 w2 } }) -}
f3f8a36c84c316fce5f42dd44d3781ed
  contradiction :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 letrec {
                   go13 :: [Lecture3.Valuation] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lecture3.Valuation]) ->
                     case ds of wild {
                       [] -> GHC.Types.True
                       : y ys
                       -> case Lecture3.evl y f of wild1 {
                            GHC.Types.False -> go13 ys GHC.Types.True -> GHC.Types.False } }
                 } in
                 go13
                   (Lecture3.genVals
                      (Data.OldList.sortBy
                         @ Lecture3.Name
                         GHC.Classes.compareInt
                         (Data.OldList.nubBy
                            @ Lecture3.Name
                            GHC.Classes.eqInt
                            (Lecture3.allVals_pnames f))))) -}
8af398e5e6c847c1de7d902b2a029992
  convertPropToClause :: Lecture3.Form -> Main.Clause
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                   Lecture3.Prop ds1
                   -> case ds1 of wild1 { GHC.Types.I# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT
                        -> GHC.Types.: @ GHC.Types.Int wild1 (GHC.Types.[] @ GHC.Types.Int)
                        0# -> Main.cnf2cls4 } }
                   Lecture3.Neg ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.[] @ GHC.Types.Int
                        Lecture3.Prop ds2
                        -> case ds2 of wild2 { GHC.Types.I# ds3 ->
                           case ds3 of ds4 {
                             DEFAULT
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I# (GHC.Prim.negateInt# ds4))
                                  (GHC.Types.[] @ GHC.Types.Int)
                             0# -> Main.cnf2cls2 } } } }) -}
7172bbbd135de3f13b0c18e2f7912825
  convertToCNF :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (form1 :: Lecture3.Form) ->
                 Main.applyDistributiveLaw
                   (Main.convertToCNF_go6 (Main.applyDeMorganLaw form1))) -}
4ecaed62af0c55426904a717aca3cda9
  convertToCNF_go6 :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
69fb7f569e0fbbf5cbb92276f8765ab1
  curRand :: Main.TreeState -> GHC.Types.Int
  RecSel Left Main.TreeState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.TreeState) ->
                 case ds of wild { Main.TreeState ds1 ds2 ds3 -> ds3 }) -}
87dfcaf2445aa1240400dcfd6b004a69
  dnf :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, Strictness: <L,U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (f :: Lecture3.Form) ->
                 Lecture3.Dsj
                   (GHC.Base.build
                      @ Lecture3.Form
                      (\ @ b1
                         (c :: Lecture3.Form -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [(Lecture3.Name, GHC.Types.Bool)]
                         @ b1
                         (GHC.Base.mapFB
                            @ Lecture3.Form
                            @ b1
                            @ [(Lecture3.Name, GHC.Types.Bool)]
                            c
                            Main.valuationToCnjClause)
                         n
                         (Main.trueEvals f)))) -}
f4f08d417cde41fa63a20691583622e9
  dnfProbe :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.dnfProbe1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
ab19777a23d9ffdf876638f58bbc0a9e
  dnfProbe1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wdnfProbe ww1 ww3 w2 } }) -}
4edcfaaf715d74980eb719020fa93487
  doRandomlyNegate ::
    [GHC.Types.Float] -> Main.TreeState -> Main.TreeState
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U(U))>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [GHC.Types.Float]) (w1 :: Main.TreeState) ->
                 case Main.$wdoRandomlyNegate w w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 Main.TreeState ww1 ww2 ww3 }) -}
9f2fa3c6e964740fb47a0e8b11bbdda5
  entails :: Lecture3.Form -> Lecture3.Form -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.entails1
                  `cast`
                (<Lecture3.Form>_R
                 ->_R <Lecture3.Form>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
daa436a2dc96e4921888963916e0f840
  entails1 ::
    Lecture3.Form -> Lecture3.Form -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (f :: Lecture3.Form) (g :: Lecture3.Form) ->
                 Main.entails_go (Main.truthTable f g)) -}
cd624b61083b7a8a58306f0a3ccb95b6
  entails_go ::
    [(GHC.Types.Bool, GHC.Types.Bool)] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f5e3a2b2f8b97ec6c078800cc6ca6331
  equiv :: Lecture3.Form -> Lecture3.Form -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.equiv1
                  `cast`
                (<Lecture3.Form>_R
                 ->_R <Lecture3.Form>_R
                 ->_R Data.Semigroup.Internal.N:All[0]) -}
1ac8b887f882f80308f6629c1f3109d4
  equiv1 ::
    Lecture3.Form -> Lecture3.Form -> Data.Semigroup.Internal.All
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (f :: Lecture3.Form) (g :: Lecture3.Form) ->
                 Main.equiv_go (Main.truthTable f g)) -}
b77fe9a5372bca405a853fcceb5fbfbe
  equiv_go ::
    [(GHC.Types.Bool, GHC.Types.Bool)] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8ee8128ee4070e2a21b075faa6b70ad1
  falseEvals :: Lecture3.Form -> [Lecture3.Valuation]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 GHC.List.filter
                   @ [(Lecture3.Name, GHC.Types.Bool)]
                   (\ (x :: Lecture3.Valuation) ->
                    case Lecture3.evl x f of wild {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False })
                   (Lecture3.genVals
                      (Data.OldList.sortBy
                         @ Lecture3.Name
                         GHC.Classes.compareInt
                         (Data.OldList.nubBy
                            @ Lecture3.Name
                            GHC.Classes.eqInt
                            (Lecture3.allVals_pnames f))))) -}
69fb7f569e0fbbf5cbb92276f8765ab1
  form :: Main.TreeState -> Lecture3.Form
  RecSel Left Main.TreeState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.TreeState) ->
                 case ds of wild { Main.TreeState ds1 ds2 ds3 -> ds2 }) -}
ea7ebac789aed159474f7bd1632f3dbb
  formToCls :: Lecture3.Form -> Main.Clauses
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (f :: Lecture3.Form) ->
                 Main.cnf2cls
                   (Main.applyDistributiveLaw
                      (Main.convertToCNF_go6 (Main.applyDeMorganLaw f)))) -}
1a029ac3c96d89c6b96ab65d3b223872
  generateActualForm :: GHC.Types.IO Lecture3.Form
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.generateActualForm1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <Lecture3.Form>_R)) -}
671e2c3493ea504470526ed640fa41a0
  generateActualForm1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Lecture3.Form #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, System.Random.StdGen)
                        @ System.Random.StdGen
                        r#
                        System.Random.newStdGen2
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { System.Random.StdGen ipv2 ipv3 ->
                 (# ipv,
                    case Main.$wgenerateForm
                           (Main.generateActualForm_go b1)
                           6#
                           Main.generateActualForm2
                           0# of ww { (#,,#) ww1 ww2 ww3 ->
                    ww2 } #) } } }) -}
e2a21d0627d1e2a0328ca1898c356559
  generateActualForm2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
052d32b295d80e4b6d4bc93f7bdfefb6
  generateActualForm_go :: System.Random.StdGen -> [GHC.Types.Float]
  {- Arity: 1, Strictness: <L,U>m2 -}
79e16525769d9a9f8d54de594d94671e
  generateForm ::
    [GHC.Types.Float]
    -> GHC.Types.Int -> Main.TreeState -> Main.TreeState
  {- Arity: 3,
     Strictness: <S,U><S(S),1*U(U)><S(LLS(S)),1*U(U(U),A,1*U(U))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Float])
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.TreeState) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Main.TreeState ww3 ww4 ww5 ->
                 case ww5 of ww6 { GHC.Types.I# ww7 ->
                 case Main.$wgenerateForm
                        w
                        ww1
                        ww3
                        ww7 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Main.TreeState ww9 ww10 ww11 } } } }) -}
11c2bf602efb9ae757eee8a0ceb85a6a
  generateFormList ::
    [GHC.Types.Float]
    -> GHC.Types.Int
    -> Main.TreeState
    -> GHC.Types.Int
    -> [Main.TreeState]
    -> [Main.TreeState]
  {- Arity: 5,
     Strictness: <S,U><L,U(U)><S(LLS(S)),1*U(U(U),A,1*U(U))><L,A><L,U>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: [GHC.Types.Float])
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.TreeState)
                   (w3 :: GHC.Types.Int)
                   (w4 :: [Main.TreeState]) ->
                 case w2 of ww { Main.TreeState ww1 ww2 ww3 ->
                 case ww3 of ww4 { GHC.Types.I# ww5 ->
                 Main.$wgenerateFormList w w1 ww1 ww5 w4 } }) -}
8562bd878c91b9c7fe54f145de179a2a
  getAsList :: Lecture3.Form -> [Lecture3.Form]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT
                   -> GHC.Types.: @ Lecture3.Form wild (GHC.Types.[] @ Lecture3.Form)
                   Lecture3.Cnj x -> x
                   Lecture3.Dsj x -> x }) -}
9eef18fa13e20e7b2a9df5d79a151c44
  getCurRand ::
    Main.TreeState
    -> [GHC.Types.Float] -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3,
     Strictness: <S(LLS(S)),1*U(A,A,1*U(U))><S,1*U><S(S),1*U(U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: Main.TreeState)
                   (eta :: [GHC.Types.Float])
                   (eta1 :: GHC.Types.Int) ->
                 case ds of wild { Main.TreeState ds1 ds2 ds3 ->
                 Main.getCurRandNum ds3 eta eta1 }) -}
1a2f7a9967a1519e913c05a5e3e87e18
  getCurRandNum ::
    GHC.Types.Int
    -> [GHC.Types.Float] -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: [GHC.Types.Float])
                   (w2 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 case GHC.List.$w!!
                        @ GHC.Types.Float
                        w1
                        ww1 of wild { GHC.Types.F# x ->
                 let {
                   x1 :: GHC.Prim.Float#
                   = GHC.Prim.timesFloat# x (GHC.Prim.int2Float# ww3)
                 } in
                 let {
                   n :: GHC.Prim.Int# = GHC.Prim.float2Int# x1
                 } in
                 case GHC.Prim.ltFloat# x1 (GHC.Prim.int2Float# n) of lwild {
                   DEFAULT -> GHC.Types.I# n
                   1# -> GHC.Types.I# (GHC.Prim.-# n 1#) } } } }) -}
fad29e6355af7169962d966ac108aeae
  isCnf :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Lecture3.Prop x -> GHC.Types.True
                   Lecture3.Neg ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lecture3.Prop x -> GHC.Types.True }
                   Lecture3.Cnj formList -> Main.isCnf_go1 formList
                   Lecture3.Dsj formList -> Main.isCnf_go formList }) -}
f3c3a0af9a5b83badeab6ed711757135
  isCnf_go :: [Lecture3.Form] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f840cd568ddead6f7ce3cd979b494112
  isCnf_go1 :: [Lecture3.Form] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
fadc4d0c6de6e98e9419d64b1c4ca7af
  isConjunction :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False Lecture3.Cnj x -> GHC.Types.True }) -}
ff00b35cb68059b6353bee0a7c5e814b
  isDisjunction :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False Lecture3.Dsj x -> GHC.Types.True }) -}
795c14ce23ecca771bdd9acbbf377205
  isDnf :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Lecture3.Prop x -> GHC.Types.True
                   Lecture3.Neg ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lecture3.Prop x -> GHC.Types.True }
                   Lecture3.Cnj formList -> Main.isDnf_go1 formList
                   Lecture3.Dsj formList -> Main.isDnf_go formList }) -}
bfbc12f301d90a0710f9fe9d41ba9d6a
  isDnf_go :: [Lecture3.Form] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ec21d6fb7be178f7bd013f9cb14313db
  isDnf_go1 :: [Lecture3.Form] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b9344f0cc0d254113e736024534e72d7
  isLiteral :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Lecture3.Prop x -> GHC.Types.True
                   Lecture3.Neg ds1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lecture3.Prop x -> GHC.Types.True } }) -}
b4f9ae97a091b232a88173a93240314d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
529073e95d7e97cca9b9c5c633464b51
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
2ae627898cff160a4ab35ad5461925fa
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
d0c3868d4555689af589ad955d366891
  maxFormDepth :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
4447f61a43c9b7543d561c862c6ca9f1
  negAtoms :: Lecture3.Form -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)> -}
b2a22941fb19883eb6e48287708b2456
  negDigs :: Main.Clauses -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Clauses) ->
                 case Main.$wnegDigs w of ww { DEFAULT -> GHC.Types.I# ww }) -}
bc51d87b0f4f442617344fec5682a3b1
  negateLiteral :: Lecture3.Form -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lecture3.Form) ->
                 case ds of wild {
                   DEFAULT -> Lecture3.Neg wild Lecture3.Neg x -> x }) -}
c6812a22a9fe00658800d9b0517df883
  none ::
    Data.Foldable.Foldable t =>
    (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(LC(C(C(S)))LLLLLLLLLLLLLL),1*U(A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t :: * -> *
                   @ a
                   ($dFoldable :: Data.Foldable.Foldable t)
                   (x :: a -> GHC.Types.Bool)
                   (y :: t a) ->
                 case (Data.Foldable.foldMap
                         @ t
                         $dFoldable
                         @ Data.Semigroup.Internal.Any
                         @ a
                         Data.Semigroup.Internal.$fMonoidAny
                         x `cast` (<a>_R ->_R Sym (Data.Semigroup.Internal.N:Any[0]))
                         y)
                        `cast`
                      (Data.Semigroup.Internal.N:Any[0]) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b893a6eb35826ca15440a9aa4f18f115
  numAtoms :: Lecture3.Form -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lecture3.Form) (w1 :: GHC.Types.Int) ->
                 case Main.$wnumAtoms w w1 of ww { DEFAULT -> GHC.Types.I# ww }) -}
f4e5c687e736414aa932fa24880c65e5
  numDigs :: Main.Clauses -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Clauses) ->
                 case Main.$wnumDigs w of ww { DEFAULT -> GHC.Types.I# ww }) -}
93e9b1a8ff4d4b605a5447368b0c19f0
  optimizeOR :: [Lecture3.Form] -> [Lecture3.Form]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
23c47b134e4d0f4ea5cad106b9badef6
  pAndNotP :: Lecture3.Form
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Lecture3.Cnj Main.pAndNotP1) -}
eb57f168fbb08062df93590278fa17d8
  pAndNotP1 :: [Lecture3.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lecture3.Form
                   Lecture3.p
                   Main.pAndNotP2) -}
c080d76f89dd0beb91da6f8a42f6d80f
  pAndNotP2 :: [Lecture3.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lecture3.Form
                   Main.pAndNotP3
                   (GHC.Types.[] @ Lecture3.Form)) -}
cd24027d6c401232ddad085f4aeb0008
  pAndNotP3 :: Lecture3.Form
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Lecture3.Neg Lecture3.p) -}
b9224f84b735e4905cc0ed15e73ac5d4
  pAndQ :: Lecture3.Form
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Lecture3.Cnj Main.pAndQ1) -}
ef558d97f6e86cce45427fda1e78028b
  pAndQ1 :: [Lecture3.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Lecture3.Form Lecture3.p Main.pAndQ2) -}
c2071a06c61b5524933e9ff54fffd3fc
  pAndQ2 :: [Lecture3.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lecture3.Form
                   Lecture3.q
                   (GHC.Types.[] @ Lecture3.Form)) -}
4e84d7cc2e1eb7b468ab5fd7bb6dbb10
  pOrNotP :: Lecture3.Form
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Lecture3.Dsj Main.pAndNotP1) -}
69c24542eb180428957103e10acfac5e
  pOrQ :: Lecture3.Form
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Lecture3.Dsj Main.pAndQ1) -}
342ddbf03be3c2962c1585841729f2ca
  parserTest :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.parserTest1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
c12b88159f85445f5172b7afe79be50e
  parserTest1 ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wparserTest ww1 ww3 w2 } }) -}
ec709f2241fe41057df4288ef90c04e3
  propNumAtoms :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 case Main.$wnumAtoms
                        (Main.applyDistributiveLaw
                           (Main.convertToCNF_go6 (Main.applyDeMorganLaw f)))
                        Main.propNumAtoms1 of ww { DEFAULT ->
                 case Main.$wnumDigs
                        (Main.cnf2cls
                           (Main.applyDistributiveLaw
                              (Main.convertToCNF_go6
                                 (Main.applyDeMorganLaw f)))) of ww1 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww ww1) } }) -}
d01ed083d62ea12257567604c5c71033
  propNumAtoms1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
231fa46e4fd969d965db622499cd40f3
  propNumNegs :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 case Main.negAtoms
                        (Main.applyDistributiveLaw
                           (Main.convertToCNF_go6 (Main.applyDeMorganLaw f)))
                        Main.propNumAtoms1 of wild { GHC.Types.I# x ->
                 case Main.$wnegDigs
                        (Main.cnf2cls
                           (Main.applyDistributiveLaw
                              (Main.convertToCNF_go6
                                 (Main.applyDeMorganLaw f)))) of ww { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# x ww) } }) -}
7117d69fb45c54769e81f33e462066cd
  randomNumberStream :: GHC.Types.IO [GHC.Types.Float]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.randomNumberStream1
                  `cast`
                (Sym (GHC.Types.N:IO[0] <[GHC.Types.Float]>_R)) -}
b4bc88eff794168590ce7b59ceba4bf2
  randomNumberStream1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Float] #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case System.Random.theStdGen
                        `cast`
                      (GHC.IORef.N:IORef[0] <System.Random.StdGen>_N) of wild { GHC.STRef.STRef r# ->
                 case GHC.Prim.atomicModifyMutVar#
                        @ GHC.Prim.RealWorld
                        @ System.Random.StdGen
                        @ (System.Random.StdGen, System.Random.StdGen)
                        @ System.Random.StdGen
                        r#
                        System.Random.newStdGen2
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of b1 { System.Random.StdGen ipv2 ipv3 ->
                 (# ipv, Main.generateActualForm_go b1 #) } } }) -}
ce5701b5aaa448eb77f3d454b7bb59fb
  removeDuplicates :: GHC.Classes.Eq a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (eta :: [a]) ->
                 letrec {
                   go13 :: [a] -> [a] -> [a]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [a]) (eta1 :: [a]) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> case GHC.List.elem @ a $dEq y eta1 of wild1 {
                            GHC.Types.False
                            -> go13
                                 ys
                                 (GHC.Base.++ @ a eta1 (GHC.Types.: @ a y (GHC.Types.[] @ a)))
                            GHC.Types.True -> go13 ys eta1 } }
                 } in
                 go13 eta (GHC.Types.[] @ a)) -}
1bff900559c7c5a32cc3adc7c09ab865
  removeDuplicates_$sremoveDuplicates ::
    [Lecture3.Form] -> [Lecture3.Form]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: [Lecture3.Form]) ->
                 Main.removeDuplicates_go eta (GHC.Types.[] @ Lecture3.Form)) -}
b4764697e44442e2b770115ac4edbfcb
  removeDuplicates_go ::
    [Lecture3.Form] -> [Lecture3.Form] -> [Lecture3.Form]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U> -}
8306d65e82ee3a9cf29eb1bcbd767e0c
  tautology :: Lecture3.Form -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.tautology1
                  `cast`
                (<Lecture3.Form>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
54d9286f47f3a535adea18016d3e8170
  tautology1 :: Lecture3.Form -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 letrec {
                   go13 :: [Lecture3.Valuation] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lecture3.Valuation]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> case Lecture3.evl y f of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                            GHC.Types.True -> go13 ys } }
                 } in
                 go13
                   (Lecture3.genVals
                      (Data.OldList.sortBy
                         @ Lecture3.Name
                         GHC.Classes.compareInt
                         (Data.OldList.nubBy
                            @ Lecture3.Name
                            GHC.Classes.eqInt
                            (Lecture3.allVals_pnames f))))) -}
8cb8aa27058c92d36d9488cb312b0937
  testFormProperty ::
    (Lecture3.Form -> GHC.Types.Bool)
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  {- Arity: 4,
     Strictness: <L,1*C1(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.testFormProperty1
                  `cast`
                (<Lecture3.Form -> GHC.Types.Bool>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
957afbc42e506fbfff354cc1eb5adb80
  testFormProperty1 ::
    (Lecture3.Form -> GHC.Types.Bool)
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4,
     Strictness: <L,1*C1(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Lecture3.Form -> GHC.Types.Bool)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wtestFormProperty w ww1 ww3 w3 } }) -}
f53eedf73165c46dfeb1f1a32e7828bd
  testFormProperty2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.testFormProperty3) -}
9cb18582b24f78a4ec00a82dfcff1710
  testFormProperty3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" tests passed\ESC[0m"#) -}
131f2dcb5a324ea6f324e0fda75e0d58
  testFormProperty4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\ESC[32m"#) -}
8cc3d6859710e30b81c6e0c54b45674d
  testFormProperty5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("pass on: "#) -}
e1b5401cfb8aabcd4f92207adc9daa61
  testFormProperty6 :: Lecture3.Form -> GHC.Types.IO ()
  {- Arity: 1, Strictness: <B,1*U>x -}
d5c6cb7c72a1415cfc1cee91f50790d3
  treeStateListToTreeState ::
    ([Lecture3.Form] -> Lecture3.Form)
    -> [Main.TreeState] -> Main.TreeState
  {- Arity: 2, Strictness: <L,1*C1(U)><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [Lecture3.Form] -> Lecture3.Form)
                   (w1 :: [Main.TreeState]) ->
                 Main.TreeState
                   (letrec {
                      go13 :: [Main.TreeState] -> Main.TreeState -> GHC.Types.Int
                        <join 2> {- Arity: 2, Strictness: <S,U><L,U(U,A,A)>m -}
                      = \ (ds :: [Main.TreeState]) (eta :: Main.TreeState) ->
                        case ds of wild {
                          [] -> case eta of wild1 { Main.TreeState ds1 ds2 ds3 -> ds1 }
                          : y ys -> go13 ys y }
                    } in
                    go13 w1 (GHC.List.lastError @ Main.TreeState))
                   (w (GHC.Base.map @ Main.TreeState @ Lecture3.Form Main.form w1))
                   (letrec {
                      go13 :: [Main.TreeState] -> Main.TreeState -> GHC.Types.Int
                        <join 2> {- Arity: 2, Strictness: <S,U><L,U(A,A,U)>m -}
                      = \ (ds :: [Main.TreeState]) (eta :: Main.TreeState) ->
                        case ds of wild {
                          [] -> case eta of wild1 { Main.TreeState ds1 ds2 ds3 -> ds3 }
                          : y ys -> go13 ys y }
                    } in
                    go13 w1 (GHC.List.lastError @ Main.TreeState))) -}
8777f642ad91a30c41ebaffd5bd4f5a9
  trueEvals :: Lecture3.Form -> [Lecture3.Valuation]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (f :: Lecture3.Form) ->
                 GHC.List.filter
                   @ [(Lecture3.Name, GHC.Types.Bool)]
                   (\ (ds :: Lecture3.Valuation) -> Lecture3.evl ds f)
                   (Lecture3.genVals
                      (Data.OldList.sortBy
                         @ Lecture3.Name
                         GHC.Classes.compareInt
                         (Data.OldList.nubBy
                            @ Lecture3.Name
                            GHC.Classes.eqInt
                            (Lecture3.allVals_pnames f))))) -}
55aed60940ee180a829d4199fe5e56b6
  truthTable ::
    Lecture3.Form
    -> Lecture3.Form -> [(GHC.Types.Bool, GHC.Types.Bool)]
  {- Arity: 2, Strictness: <S,U><S,U> -}
e4e554cf6cbb89aec7ccaae1a1b4cd54
  valuationToCnjClause :: Lecture3.Valuation -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m3,
     Unfolding: InlineRule (1, True, False)
                (\ (v :: Lecture3.Valuation) ->
                 Lecture3.Cnj
                   (GHC.Base.build
                      @ Lecture3.Form
                      (\ @ b1
                         (c :: Lecture3.Form -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (Lecture3.Name, GHC.Types.Bool)
                         @ b1
                         (GHC.Base.mapFB
                            @ Lecture3.Form
                            @ b1
                            @ (Lecture3.Name, GHC.Types.Bool)
                            c
                            Main.valuationToCnjClause1)
                         n
                         v))) -}
1399a25667e6293cc3344f97fbc6920c
  valuationToCnjClause1 ::
    (Lecture3.Name, GHC.Types.Bool) -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (Lecture3.Name, GHC.Types.Bool)) ->
                 case x of wild { (,) ds1 y ->
                 case y of wild1 {
                   GHC.Types.False -> Lecture3.Neg (Lecture3.Prop ds1)
                   GHC.Types.True -> Lecture3.Prop ds1 } }) -}
de21d07bb546f14a3596eec71a123449
  valuationToDsjClause :: Lecture3.Valuation -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (v :: Lecture3.Valuation) ->
                 Lecture3.Dsj
                   (GHC.Base.build
                      @ Lecture3.Form
                      (\ @ b1
                         (c :: Lecture3.Form -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (Lecture3.Name, GHC.Types.Bool)
                         @ b1
                         (GHC.Base.mapFB
                            @ Lecture3.Form
                            @ b1
                            @ (Lecture3.Name, GHC.Types.Bool)
                            c
                            Main.valuationToDsjClause1)
                         n
                         v))) -}
a983466241c7060a8134ac4d4fec04bd
  valuationToDsjClause1 ::
    (Lecture3.Name, GHC.Types.Bool) -> Lecture3.Form
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: (Lecture3.Name, GHC.Types.Bool)) ->
                 case x of wild { (,) ds1 y ->
                 case y of wild1 {
                   GHC.Types.False -> Lecture3.Prop ds1
                   GHC.Types.True -> Lecture3.Neg (Lecture3.Prop ds1) } }) -}
"SPEC removeDuplicates @ Form" forall ($dEq :: GHC.Classes.Eq
                                                 Lecture3.Form)
  Main.removeDuplicates @ Lecture3.Form $dEq
  = Main.removeDuplicates_$sremoveDuplicates
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

