
==================== FINAL INTERFACE ====================
2018-10-26 15:00:50.769427918 UTC

interface main:Main 8043
  interface hash: 12fffba5d5c1385d6fa269d82cb041e5
  ABI hash: b72a665cdac1ff98a42fc9c29c989376
  export-list hash: 3f8badb858634dde8b89b896744da350
  orphan hash: 83a97092530c6cee84b4317f79830876
  flag hash: 259cd8c781a7fc7b4d4d733743ed9a5d
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.-->
  Main.form0
  Main.form1
  Main.form2
  Main.form3
  Main.givenRelation
  Main.gordon1
  Main.gordon2
  Main.gordon3
  Main.gordon4
  Main.grow
  Main.isSerial
  Main.main
  Main.nsub
  Main.p
  Main.propEqualSize
  Main.propExample
  Main.propIfNoAtomSetSizeMoreThanOne
  Main.propNotSerialIfRelationHasLowerSize
  Main.propReflexiveAlwaysSerial
  Main.propSetNotEmpty
  Main.q
  Main.quickCheckGordon
  Main.r
  Main.setLength
  Main.showLst
  Main.showRest
  Main.step611
  Main.sub
  Main.tree
  Main.BoundedNumber{Main.BoundedNumber}
  Main.BoundedNumberAlt{Main.BoundedNumberAlt}
  Main.Form{Main.Cnj Main.Dsj Main.Equiv Main.Impl Main.Neg Main.Prop}
  Main.LargeNumber{Main.LargeNumber}
  Main.Name
  Main.Rel
  Main.Tree{Main.T}
module dependencies: SetOrd
package dependencies: QuickCheck-2.11.3 array-0.5.2.0 base-4.11.1.0
                      containers-0.5.11.0 deepseq-1.4.3.0 ghc-boot-th-8.4.3
                      ghc-prim-0.5.2.0 integer-gmp-1.0.2.0 monad-loops-0.4.3
                      pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      template-haskell-2.13.0.0 tf-random-0.5 time-1.8.0.2
                      transformers-0.5.5.0
orphans: time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.11.3:Test.QuickCheck e00d138ee3234e83a31cc3113c8c8ffb
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Arbitrary 749c030890709ce50a65277c8ad56400
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Gen 18d7f741d47ea7234320fe42d69d1321
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Modifiers ac69053852b38b6b92f9a1761d7c4517
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Monadic f6cd7cfce1092016c7dfa531145838b9
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Test 5c80e8a0569651177c75db83b77c7ff4
import  -/  base-4.11.1.0:Control.Exception 3d8e6cda20877f889f07bc7c0f5cac36
import  -/  base-4.11.1.0:Control.Monad c5f960c67d822497578bffbd3e4c01cf
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Debug.Trace 7d99b5cfd8ae9f4b50938e4fedeaadef
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  SetOrd 20d6f0f41725706843d2ab2f20e545d8
  exports: e89ac246b305a3091bdfb86588a1cb82
  Set 94a6edde28d7ac9df7fa72247213c3ef
  Set 55dc3292b9803e1d32b9c4b5d42bfa6e
  unionSet 1135ee0042225ae7272986fecae922ec
import  -/  monad-loops-0.4.3:Control.Monad.Loops e76938e3a155629c9760ce247778d85e
import  -/  random-1.1:System.Random 31994b60c33f032d578c64a928f735f7
fixities infix 1 -->
e447f9c18d4c9157d2f5711c5cbca4a2
  $fArbitraryBoundedNumber ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.BoundedNumber
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumber
                  Main.$fArbitraryBoundedNumber1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoundedNumber>_R))
                  Main.$fArbitraryBoundedNumber_$cshrink -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fArbitraryBoundedNumber1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.BoundedNumber
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$carbitrary ww1 ww2 ww3 ww4 w1 of ww7 { DEFAULT ->
                 (GHC.Types.I# ww7) `cast` (Sym (Main.N:BoundedNumber[0])) } }) -}
2a573a8341108cd5ecdd3ddbfd73f754
  $fArbitraryBoundedNumber2 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Modifiers.NonNegative GHC.Types.Int
  {- Unfolding: (Test.QuickCheck.Modifiers.$fArbitraryNonNegative1
                   @ GHC.Types.Int
                   GHC.Num.$fNumInt
                   GHC.Classes.$fOrdInt
                   Test.QuickCheck.Arbitrary.$fArbitraryInt) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fArbitraryBoundedNumberAlt ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.BoundedNumberAlt
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumberAlt
                  Main.$fArbitraryBoundedNumberAlt1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoundedNumberAlt>_R))
                  Main.$fArbitraryBoundedNumberAlt_$cshrink -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fArbitraryBoundedNumberAlt1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.BoundedNumberAlt
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 Main.$w$carbitrary1 ww1 ww2 ww3 ww4 ww8 } }) -}
1e2f0ae67a9ae3e727988a9d41843575
  $fArbitraryBoundedNumberAlt2 :: GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Int) ->
                 case x of wild { GHC.Types.I# x1 ->
                 case GHC.Prim.>=# x1 0# of lwild {
                   DEFAULT -> GHC.Types.False
                   1#
                   -> GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# x1 10#) } }) -}
c1b04c846a92466f4f075e5aac61502c
  $fArbitraryBoundedNumberAlt3 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 case Test.QuickCheck.Arbitrary.$w$sarbitrarySizedIntegral
                        ww1
                        ww2
                        ww3
                        ww4
                        ww8 of ww9 { DEFAULT ->
                 case GHC.Prim.>=# ww9 0# of lwild {
                   DEFAULT -> GHC.Types.I# (GHC.Prim.negateInt# ww9)
                   1# -> GHC.Types.I# ww9 } } } }) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fArbitraryBoundedNumberAlt_$cshrink ::
    Main.BoundedNumberAlt -> [Main.BoundedNumberAlt]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.BoundedNumberAlt) ->
                 GHC.Types.[] @ Main.BoundedNumberAlt) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fArbitraryBoundedNumber_$cshrink ::
    Main.BoundedNumber -> [Main.BoundedNumber]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.BoundedNumber) ->
                 GHC.Types.[] @ Main.BoundedNumber) -}
827bc82274996275a3c8460b1e024af0
  $fArbitraryLargeNumber ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.LargeNumber
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.LargeNumber
                  Main.$fArbitraryLargeNumber1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.LargeNumber>_R))
                  Main.$fArbitraryLargeNumber_$cshrink -}
827bc82274996275a3c8460b1e024af0
  $fArbitraryLargeNumber1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.LargeNumber
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww1
                        ww2
                        ww3
                        ww4 of ww7 { (#,#) ww8 ww9 ->
                 case (Main.$fArbitraryBoundedNumber2
                         ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                         w1)
                        `cast`
                      (Test.QuickCheck.Modifiers.N:NonNegative[0]
                           <GHC.Types.Int>_R) of wild { GHC.Types.I# x ->
                 (GHC.Types.I# (GHC.Prim.+# x 100#))
                   `cast`
                 (Sym (Main.N:LargeNumber[0])) } } }) -}
827bc82274996275a3c8460b1e024af0
  $fArbitraryLargeNumber_$cshrink ::
    Main.LargeNumber -> [Main.LargeNumber]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.LargeNumber) -> GHC.Types.[] @ Main.LargeNumber) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fEqBoundedNumber :: GHC.Classes.Eq Main.BoundedNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumber
                  GHC.Classes.eqInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.neInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fEqBoundedNumberAlt :: GHC.Classes.Eq Main.BoundedNumberAlt
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumberAlt
                  GHC.Classes.eqInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.neInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R) -}
7f3962d1bd040eae05a691575220f6ab
  $fEqForm :: GHC.Classes.Eq Main.Form
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Form Main.$fEqForm_$c== Main.$fEqForm_$c/= -}
7f3962d1bd040eae05a691575220f6ab
  $fEqForm_$c/= :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fEqForm_$c== x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7f3962d1bd040eae05a691575220f6ab
  $fEqForm_$c== :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
827bc82274996275a3c8460b1e024af0
  $fEqLargeNumber :: GHC.Classes.Eq Main.LargeNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.LargeNumber
                  GHC.Classes.eqInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.neInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R) -}
87342d69815fc8ca5c7bc9933326b663
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Main.Tree a)
                  (Main.$fEqTree_$c== @ a v)
                  (Main.$fEqTree_$c/= @ a v) -}
87342d69815fc8ca5c7bc9933326b663
  $fEqTree_$c/= ::
    GHC.Classes.Eq a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fEqTree_$c== @ a $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
87342d69815fc8ca5c7bc9933326b663
  $fEqTree_$c== ::
    GHC.Classes.Eq a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fOrdBoundedNumber :: GHC.Classes.Ord Main.BoundedNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumber
                  Main.$fEqBoundedNumber
                  GHC.Classes.compareInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Ordering>_R)
                  GHC.Classes.ltInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.leInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.gtInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.geInt
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdInt_$cmax
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0]))
                  GHC.Classes.$fOrdInt_$cmin
                    `cast`
                  (Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])
                   ->_R Sym (Main.N:BoundedNumber[0])) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fOrdBoundedNumberAlt :: GHC.Classes.Ord Main.BoundedNumberAlt
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumberAlt
                  Main.$fEqBoundedNumberAlt
                  GHC.Classes.compareInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Ordering>_R)
                  GHC.Classes.ltInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.leInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.gtInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.geInt
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdInt_$cmax
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0]))
                  GHC.Classes.$fOrdInt_$cmin
                    `cast`
                  (Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])
                   ->_R Sym (Main.N:BoundedNumberAlt[0])) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm :: GHC.Classes.Ord Main.Form
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Form
                  Main.$fEqForm
                  Main.$fOrdForm_$ccompare
                  Main.$fOrdForm_$c<
                  Main.$fOrdForm_$c<=
                  Main.$fOrdForm_$c>
                  Main.$fOrdForm_$c>=
                  Main.$fOrdForm_$cmax
                  Main.$fOrdForm_$cmin -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$c< :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$c<= :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$c> :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$c>= :: Main.Form -> Main.Form -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$ccompare :: Main.Form -> Main.Form -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U> -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$cmax :: Main.Form -> Main.Form -> Main.Form
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
7f3962d1bd040eae05a691575220f6ab
  $fOrdForm_$cmin :: Main.Form -> Main.Form -> Main.Form
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (y :: Main.Form) ->
                 case Main.$fOrdForm_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
827bc82274996275a3c8460b1e024af0
  $fOrdLargeNumber :: GHC.Classes.Ord Main.LargeNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.LargeNumber
                  Main.$fEqLargeNumber
                  GHC.Classes.compareInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Ordering>_R)
                  GHC.Classes.ltInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.leInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.gtInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.geInt
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdInt_$cmax
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0]))
                  GHC.Classes.$fOrdInt_$cmin
                    `cast`
                  (Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])
                   ->_R Sym (Main.N:LargeNumber[0])) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree :: GHC.Classes.Ord a => GHC.Classes.Ord (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Main.Tree a)
                  (Main.$fOrdTree_$cp1Ord @ a v)
                  (Main.$fOrdTree_$ccompare @ a v)
                  (Main.$fOrdTree_$c< @ a v)
                  (Main.$fOrdTree_$c<= @ a v)
                  (\ (a1 :: Main.Tree a) (b :: Main.Tree a) ->
                   Main.$fOrdTree_$c< @ a v b a1)
                  (Main.$fOrdTree_$c>= @ a v)
                  (Main.$fOrdTree_$cmax @ a v)
                  (Main.$fOrdTree_$cmin @ a v) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$c< ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)> -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$c<= ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Main.Tree a)
                   (b :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd b a1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$c>= ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Main.Tree a)
                   (b :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$ccompare ::
    GHC.Classes.Ord a =>
    Main.Tree a -> Main.Tree a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)> -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$cmax ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> Main.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$cmin ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> Main.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
87342d69815fc8ca5c7bc9933326b663
  $fOrdTree_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Main.Tree a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Main.$fEqTree @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fShowBoundedNumber :: GHC.Show.Show Main.BoundedNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumber
                  Main.$fShowBoundedNumber_$cshowsPrec
                  Main.$fShowBoundedNumber_$cshow
                  Main.$fShowBoundedNumber_$cshowList -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fShowBoundedNumber1 :: Main.BoundedNumber -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: (\ (w :: Main.BoundedNumber) (w1 :: GHC.Base.String) ->
                 Main.$w$cshowsPrec 0# w w1) -}
1e131ee3528892ac2f7bf79d2642202b
  $fShowBoundedNumber2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoundedNumber "#) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fShowBoundedNumberAlt :: GHC.Show.Show Main.BoundedNumberAlt
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoundedNumberAlt
                  Main.$fShowBoundedNumberAlt_$cshowsPrec
                  Main.$fShowBoundedNumberAlt_$cshow
                  Main.$fShowBoundedNumberAlt_$cshowList -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fShowBoundedNumberAlt1 :: Main.BoundedNumberAlt -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: (\ (w :: Main.BoundedNumberAlt)
                   (w1 :: GHC.Base.String) ->
                 Main.$w$cshowsPrec1 0# w w1) -}
473054e16405e773d6e0c7f78ec3b981
  $fShowBoundedNumberAlt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoundedNumberAlt "#) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fShowBoundedNumberAlt_$cshow ::
    Main.BoundedNumberAlt -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>,
     Unfolding: (\ (x :: Main.BoundedNumberAlt) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoundedNumberAlt2
                   (case x `cast`
                         (Main.N:BoundedNumberAlt[0]) of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fShowBoundedNumberAlt_$cshowList ::
    [Main.BoundedNumberAlt] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.BoundedNumberAlt]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Main.BoundedNumberAlt
                   Main.$fShowBoundedNumberAlt1
                   ls
                   s) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $fShowBoundedNumberAlt_$cshowsPrec ::
    GHC.Types.Int -> Main.BoundedNumberAlt -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.BoundedNumberAlt)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec1 ww1 w1 w2 }) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fShowBoundedNumber_$cshow :: Main.BoundedNumber -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>,
     Unfolding: (\ (x :: Main.BoundedNumber) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoundedNumber2
                   (case x `cast`
                         (Main.N:BoundedNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fShowBoundedNumber_$cshowList ::
    [Main.BoundedNumber] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.BoundedNumber]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Main.BoundedNumber
                   Main.$fShowBoundedNumber1
                   ls
                   s) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $fShowBoundedNumber_$cshowsPrec ::
    GHC.Types.Int -> Main.BoundedNumber -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.BoundedNumber)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec ww1 w1 w2 }) -}
7f3962d1bd040eae05a691575220f6ab
  $fShowForm :: GHC.Show.Show Main.Form
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Form
                  Main.$fShowForm_$cshowsPrec
                  Main.$fShowForm_$cshow
                  Main.$fShowForm_$cshowList -}
7f3962d1bd040eae05a691575220f6ab
  $fShowForm1 :: Main.Form -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Main.Form) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n (Main.$fShowForm_$cshow x))
                   s) -}
7f3962d1bd040eae05a691575220f6ab
  $fShowForm_$cshow :: Main.Form -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
7f3962d1bd040eae05a691575220f6ab
  $fShowForm_$cshowList :: [Main.Form] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Form]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.Form Main.$fShowForm1 ls s) -}
7f3962d1bd040eae05a691575220f6ab
  $fShowForm_$cshowsPrec ::
    GHC.Types.Int -> Main.Form -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int) (x :: Main.Form) (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n (Main.$fShowForm_$cshow x))
                   s) -}
827bc82274996275a3c8460b1e024af0
  $fShowLargeNumber :: GHC.Show.Show Main.LargeNumber
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.LargeNumber
                  Main.$fShowLargeNumber_$cshowsPrec
                  Main.$fShowLargeNumber_$cshow
                  Main.$fShowLargeNumber_$cshowList -}
827bc82274996275a3c8460b1e024af0
  $fShowLargeNumber1 :: Main.LargeNumber -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: (\ (w :: Main.LargeNumber) (w1 :: GHC.Base.String) ->
                 Main.$w$cshowsPrec2 0# w w1) -}
97a097ccaaa4cc69395e93649765445c
  $fShowLargeNumber2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LargeNumber "#) -}
827bc82274996275a3c8460b1e024af0
  $fShowLargeNumber_$cshow :: Main.LargeNumber -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>,
     Unfolding: (\ (x :: Main.LargeNumber) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowLargeNumber2
                   (case x `cast` (Main.N:LargeNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
827bc82274996275a3c8460b1e024af0
  $fShowLargeNumber_$cshowList ::
    [Main.LargeNumber] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.LargeNumber]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Main.LargeNumber
                   Main.$fShowLargeNumber1
                   ls
                   s) -}
827bc82274996275a3c8460b1e024af0
  $fShowLargeNumber_$cshowsPrec ::
    GHC.Types.Int -> Main.LargeNumber -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.LargeNumber)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec2 ww1 w1 w2 }) -}
87342d69815fc8ca5c7bc9933326b663
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Main.Tree a)
                  (Main.$fShowTree_$cshowsPrec @ a v)
                  (Main.$fShowTree_$cshow @ a v)
                  (Main.$fShowTree_$cshowList @ a v) -}
8a2e1ef3cf23b180cf649dea574db704
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
87342d69815fc8ca5c7bc9933326b663
  $fShowTree_$cshow ::
    GHC.Show.Show a => Main.Tree a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Main.Tree a) ->
                 Main.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   Main.$fShowTree1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87342d69815fc8ca5c7bc9933326b663
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Main.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Main.Tree a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Tree a)
                   (Main.$fShowTree_$cshowsPrec @ a $dShow Main.$fShowTree1)
                   ls
                   s) -}
87342d69815fc8ca5c7bc9933326b663
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Main.Tree a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Tree a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Main.T ww3 ww4 ->
                 Main.$w$cshowsPrec3 @ a w ww1 ww3 ww4 } }) -}
a231cde55f0a16740b156e8ced22b3d2
  $s$fArbitraryZipList1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w1 :: Test.QuickCheck.Random.QCGen) (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w2 of ww7 { GHC.Types.I# ww8 ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ GHC.Types.Int
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                   ww1
                   ww2
                   ww3
                   ww4
                   ww8 } }) -}
70fe008ecc420925c316daac7946fc07
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  Main.$s$fEq(,)_$s$fEq(,)_$c/= -}
d9c29de69e24759049df94d820948480
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int))
                   (y :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
7c4fcc93f69673d2b27fdc8eada75ea9
  $s$fShow[] :: GHC.Show.Show [(GHC.Types.Int, GHC.Types.Int)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [(GHC.Types.Int, GHC.Types.Int)]
                  (\ (ds :: GHC.Types.Int)
                     (ls :: [(GHC.Types.Int, GHC.Types.Int)])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Types.Int, GHC.Types.Int)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        GHC.Show.$fShowInt
                        GHC.Show.$fShowInt
                        GHC.Show.$fShow(,)1)
                     ls
                     s)
                  (\ (x :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                   GHC.Show.showList__
                     @ (GHC.Types.Int, GHC.Types.Int)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        GHC.Show.$fShowInt
                        GHC.Show.$fShowInt
                        GHC.Show.$fShow(,)1)
                     x
                     (GHC.Types.[] @ GHC.Types.Char))
                  (\ (ls :: [[(GHC.Types.Int, GHC.Types.Int)]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ [(GHC.Types.Int, GHC.Types.Int)]
                     (\ (ls1 :: [(GHC.Types.Int, GHC.Types.Int)])
                        (s1 :: GHC.Base.String)[OneShot] ->
                      GHC.Show.showList__
                        @ (GHC.Types.Int, GHC.Types.Int)
                        (GHC.Show.$fShow(,)_$cshowsPrec
                           @ GHC.Types.Int
                           @ GHC.Types.Int
                           GHC.Show.$fShowInt
                           GHC.Show.$fShowInt
                           GHC.Show.$fShow(,)1)
                        ls1
                        s1)
                     ls
                     s) -}
b0abbca3c2d44fe5717922ce9ca894ff
  $s$fTestable(->)11 ::
    ([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable3 w ww1 ww2 ww3 ww4 w2 }) -}
b6596127cc97dd9b6d6b632d09c4dfbf
  $s$fTestable(->)12 ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> [[(GHC.Types.Int, GHC.Types.Int)]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ (GHC.Types.Int, GHC.Types.Int)
                   Main.$s$fTestable(->)13
                   eta) -}
343663ab3a9f806d2c333c34cbfcb862
  $s$fTestable(->)13 ::
    (GHC.Types.Int, GHC.Types.Int) -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S(S)L),1*U(1*U(U),U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 -> Main.$wlvl ww4 ww2 } }) -}
a2c716b464afb0105554180f9e084598
  $s$fTestable(->)14 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 Main.$wlvl1 ww1 ww2 ww3 ww4 ww8 } }) -}
2699baa4ef787e73ade972c54a2844da
  $s$fTestable(->)15 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U(U)>m,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int)[OneShot] ->
                 case eta
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww1
                        ww2
                        ww3
                        ww4 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww11 { System.Random.TF.Gen.TFGen ww12 ww13 ww10 ww14 ww15 ww16 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww12
                        ww13
                        ww10
                        ww14 of ww17 { (#,#) ww18 ww19 ->
                 (Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                    eta1,
                  Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                    ww18 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                    eta1) } } } }) -}
2713bf5947654d5ffa6ce372924cfaa9
  $s$fTestable(->)4 ::
    (GHC.Types.Int
     -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int
                         -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable w ww1 ww2 ww3 ww4 w2 }) -}
093d22a451508f7fcdcd1dc8550ced23
  $s$fTestable(->)5 ::
    (GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable1 w ww1 ww2 ww3 ww4 w2 }) -}
e67419c862743eab21938c84fe2c8f39
  $s$fTestable(->)6 ::
    (GHC.Types.Double -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Double -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable2 w ww1 ww2 ww3 ww4 w2 }) -}
3ef9b400ceb3134e7bce5e2b6f567b65
  $s^1 :: GHC.Types.Double
  {- Strictness: x -}
df2daf63ce8835a51b42b4dd91467f60
  $squickCheck3 :: [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [GHC.Types.Int]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Int
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
                   eta) -}
6a67e9c41d0efdaa047fb185e5e08a1c
  $squickCheck5 ::
    (GHC.Types.Double
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Double
                         -> GHC.Types.Int
                         -> GHC.Types.Double
                         -> GHC.Types.Double
                         -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable4 w ww1 ww2 ww3 ww4 w2 }) -}
bb89db3ad8ccf7f3b9448527f8a59008
  $tc'BoundedNumber :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11290168401333401017##
                   1670285471482429122##
                   Main.$trModule
                   Main.$tc'BoundedNumber2
                   0#
                   Main.$tc'BoundedNumber1) -}
4938c9706fd07672f245c39d4f07e2cb
  $tc'BoundedNumber1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
1e19d7a54e9d0e9f118abb8b092a81b0
  $tc'BoundedNumber2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'BoundedNumber3) -}
82aeedeaf620289b97053d7cf8c95e87
  $tc'BoundedNumber3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoundedNumber"#) -}
fbe4a20729f05a35637848c1bdece109
  $tc'BoundedNumberAlt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9216929924002633144##
                   5352647464427151662##
                   Main.$trModule
                   Main.$tc'BoundedNumberAlt2
                   0#
                   Main.$tc'BoundedNumberAlt1) -}
1073e6faf9b8c0465df82aa7b3d3c5a9
  $tc'BoundedNumberAlt1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ea95330588f476448b11b34e40ce6ce6
  $tc'BoundedNumberAlt2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'BoundedNumberAlt3) -}
be54f66d31f467d50008e6931b68d1ba
  $tc'BoundedNumberAlt3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoundedNumberAlt"#) -}
aba5cf9d3166b99ede18ed5cef20e99c
  $tc'Cnj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4208330756850368680##
                   10058103227957824765##
                   Main.$trModule
                   Main.$tc'Cnj2
                   0#
                   Main.$tc'Cnj1) -}
c77bf7ec5f1efd0b41142efe42a48868
  $tc'Cnj1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5b79c044711753a524159876885ca368
  $tc'Cnj2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Cnj3) -}
053db3ea7b5041fabe4dea1ae2df0ada
  $tc'Cnj3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Cnj"#) -}
b2f0b8123c079383be9f74812dac35f3
  $tc'Dsj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7856216472638081290##
                   7300662190635077131##
                   Main.$trModule
                   Main.$tc'Dsj1
                   0#
                   Main.$tc'Cnj1) -}
b27a441bc31670bb158bb9cd45660b3f
  $tc'Dsj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Dsj2) -}
34ab659a59f62eba09274a4b5b47c71e
  $tc'Dsj2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Dsj"#) -}
1dff7156ed6168248e8eb3900ae43086
  $tc'Equiv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3916969873504983465##
                   13017792808828979743##
                   Main.$trModule
                   Main.$tc'Equiv2
                   0#
                   Main.$tc'Equiv1) -}
6bf95c8ad25ef00ef766a21bba27d6ff
  $tc'Equiv1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ebde39f051f26906b06775ccae2a213f
  $tc'Equiv2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Equiv3) -}
ebc18b0890e227e9a2ec4656e2f35374
  $tc'Equiv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Equiv"#) -}
e7f0b9ca0f53816a50cb394aa97c217a
  $tc'Impl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8719689930190708804##
                   14554306829282138642##
                   Main.$trModule
                   Main.$tc'Impl1
                   0#
                   Main.$tc'Equiv1) -}
e7942810d472ecab4af15b0426bd3a44
  $tc'Impl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Impl2) -}
95ca8ee0092ef7e3c5b4998a9d572c17
  $tc'Impl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Impl"#) -}
a5ad34c2b5a39f7ce0ee978803907053
  $tc'LargeNumber :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13857795478788857114##
                   13835192592146373756##
                   Main.$trModule
                   Main.$tc'LargeNumber2
                   0#
                   Main.$tc'LargeNumber1) -}
6cff4ab16032f00c929a997cffdc8471
  $tc'LargeNumber1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bdb8e2fdc1ee11371ac4add6035dbc2f
  $tc'LargeNumber2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'LargeNumber3) -}
13156638acfead2d6c102d8a0dbd971b
  $tc'LargeNumber3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LargeNumber"#) -}
12d6dbadb4b6e11adfbd084abf0021e1
  $tc'Neg :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7793560789665771617##
                   16821389539079660119##
                   Main.$trModule
                   Main.$tc'Neg2
                   0#
                   Main.$tc'Neg1) -}
b815d73a0737528f70fba7bfe179f3bb
  $tc'Neg1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a8afabf20419b043a49aaaa0046f9b0d
  $tc'Neg2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Neg3) -}
888fbdff84a041872ca3b365e9d51699
  $tc'Neg3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Neg"#) -}
0999016d2278be8128f2089761e9ce0f
  $tc'Prop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11664713279280497732##
                   13337821378297450670##
                   Main.$trModule
                   Main.$tc'Prop2
                   0#
                   Main.$tc'Prop1) -}
97bcfedd624d57d950a6ed209b3fa858
  $tc'Prop1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5fc1d23d6c2364a801a6a0efbb01c831
  $tc'Prop2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Prop3) -}
e3af92953143f3ad462661951481250f
  $tc'Prop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prop"#) -}
82a89cbcc83f0fe4f847c80f8f06c803
  $tc'T :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15564654814037795574##
                   9702549696965301893##
                   Main.$trModule
                   Main.$tc'T2
                   1#
                   Main.$tc'T1) -}
cdea305a07fc7b0ce3b6fa279beed5d1
  $tc'T1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b153c59e0fc12c971d956d3caebbd8d6
  $tc'T2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'T3) -}
3c5909b1a45d9d6f6b666edd1e7deada
  $tc'T3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'T"#) -}
c1bbd4dbc513297f5544aff5cf371a04
  $tcBoundedNumber :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7474782492302384607##
                   5712311457288109238##
                   Main.$trModule
                   Main.$tcBoundedNumber1
                   0#
                   GHC.Types.krep$*) -}
ffee22165adb97f607e09ec26882100f
  $tcBoundedNumber1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcBoundedNumber2) -}
03303e8cd1939542d52c7c6488edceaf
  $tcBoundedNumber2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoundedNumber"#) -}
03e8663983e52cb60b70a675916038d1
  $tcBoundedNumberAlt :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12758758426208882083##
                   9031610580547503331##
                   Main.$trModule
                   Main.$tcBoundedNumberAlt1
                   0#
                   GHC.Types.krep$*) -}
0641ba7cfbc252bd63628268ee89b32e
  $tcBoundedNumberAlt1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcBoundedNumberAlt2) -}
f0fd82b8bf807ca3bd399e149d9204f7
  $tcBoundedNumberAlt2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoundedNumberAlt"#) -}
8f1e8d1d9ad46b5a54353cb9d40b6ea3
  $tcForm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1804977235782527232##
                   10836805395517503169##
                   Main.$trModule
                   Main.$tcForm1
                   0#
                   GHC.Types.krep$*) -}
46fa8b834a8fef482ec3e4efe5592ea6
  $tcForm1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcForm2) -}
229173a4b55c9b7bfee3814b2a54ec38
  $tcForm2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Form"#) -}
7ac4e830338d1f7f882d2920ec4a3b43
  $tcLargeNumber :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15755192995204539202##
                   3115092900676318582##
                   Main.$trModule
                   Main.$tcLargeNumber1
                   0#
                   GHC.Types.krep$*) -}
29976d3a864527b9661bae0e4d16ff27
  $tcLargeNumber1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcLargeNumber2) -}
839eb4fcc94d5918b0df2ad63bdbd442
  $tcLargeNumber2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LargeNumber"#) -}
344ba01ddc47ef15cd34a5a4090287c0
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9208051040442588375##
                   2694919957537544827##
                   Main.$trModule
                   Main.$tcTree1
                   0#
                   GHC.Types.krep$*Arr*) -}
2f5ee83cf42ce248da8c643cf86c71f4
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTree2) -}
3b8c48e27778354ef7c721b0c45bea2d
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
3cb3411b3410df30a8e1025cccd2e775
  $w$carbitrary ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case (Main.$fArbitraryBoundedNumber2
                         ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                         w)
                        `cast`
                      (Test.QuickCheck.Modifiers.N:NonNegative[0]
                           <GHC.Types.Int>_R) of wild1 { GHC.Types.I# x ->
                 GHC.Classes.modInt# x 10# } }) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $w$carbitrary1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Main.BoundedNumberAlt
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww8 of ww5 { System.Random.TF.Gen.TFGen ww6 ww10 ww11 ww12 ww13 ww14 ->
                 (Test.QuickCheck.Gen.$wsuchThat
                    @ GHC.Types.Int
                    Main.$fArbitraryBoundedNumberAlt3
                      `cast`
                    (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                    Main.$fArbitraryBoundedNumberAlt2
                    ww6
                    ww10
                    ww11
                    ww12
                    ww4)
                   `cast`
                 (Sym (Main.N:BoundedNumberAlt[0])) } }) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Main.BoundedNumber -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.BoundedNumber)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowBoundedNumber2
                        (case w `cast`
                              (Main.N:BoundedNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowBoundedNumber2
                           (case w `cast`
                                 (Main.N:BoundedNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      w1) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
9000eb4aa3cd62dbc352b5c1a7d2af70
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Main.BoundedNumberAlt -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.BoundedNumberAlt)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowBoundedNumberAlt2
                        (case w `cast`
                              (Main.N:BoundedNumberAlt[0]) of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowBoundedNumberAlt2
                           (case w `cast`
                                 (Main.N:BoundedNumberAlt[0]) of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      w1) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
827bc82274996275a3c8460b1e024af0
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Main.LargeNumber -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.LargeNumber)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowLargeNumber2
                        (case w `cast` (Main.N:LargeNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowLargeNumber2
                           (case w `cast` (Main.N:LargeNumber[0]) of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      w1) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
87342d69815fc8ca5c7bc9933326b663
  $w$cshowsPrec3 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> a -> [Main.Tree a] -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>, Inline: [0] -}
f3d89c03c6a22208c0153bcf5fec96d4
  $w$dTestable ::
    (GHC.Types.Int
     -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int
                         -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Types.Int
                   @ (GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
                   GHC.Show.$fShowInt
                   Main.$s$fTestable(->)5
                     `cast`
                   ((<GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <GHC.Types.Double
                                                                                                                                     -> GHC.Types.Double
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
f1e6570fb0154409c87e30ca62f187e8
  $w$dTestable1 ::
    (GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double
                         -> GHC.Types.Double -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Types.Double
                   @ (GHC.Types.Double -> GHC.Types.Bool)
                   GHC.Float.$fShowDouble
                   Main.$s$fTestable(->)6
                     `cast`
                   ((<GHC.Types.Double -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <GHC.Types.Double
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sarbitrarySizedFractional
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Double>_R))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sshrinkRealFrac
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
26b8322461b7f821b5323290ac30d7de
  $w$dTestable2 ::
    (GHC.Types.Double -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Types.Double
                   @ GHC.Types.Bool
                   GHC.Float.$fShowDouble
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sarbitrarySizedFractional
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Double>_R))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sshrinkRealFrac
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
9badf3fb6ea8682cd8bf774621dca14b
  $w$dTestable3 ::
    ([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: [(GHC.Types.Int, GHC.Types.Int)]
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ [(GHC.Types.Int, GHC.Types.Int)]
                   @ GHC.Types.Bool
                   Main.$s$fShow[]
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$s$fTestable(->)14
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <[(GHC.Types.Int, GHC.Types.Int)]>_R))
                   Main.$s$fTestable(->)12
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
c9db60f052ab98296151734932c9937e
  $w$dTestable4 ::
    (GHC.Types.Double
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double
                         -> GHC.Types.Int
                         -> GHC.Types.Double
                         -> GHC.Types.Double
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Types.Double
                   @ (GHC.Types.Int
                      -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool)
                   GHC.Float.$fShowDouble
                   Main.$s$fTestable(->)4
                     `cast`
                   ((<GHC.Types.Int
                      -> GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <GHC.Types.Int
                                                                                                                                     -> GHC.Types.Double
                                                                                                                                     -> GHC.Types.Double
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sarbitrarySizedFractional
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Double>_R))
                   Test.QuickCheck.Arbitrary.$fArbitraryDouble_$sshrinkRealFrac
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
a0c4cc6990a40f51522b51b66c690831
  $w$sgordon4 ::
    GHC.Types.Double
    -> GHC.Prim.Int#
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Double
  {- Arity: 4, Strictness: <L,U(U)><S,U><L,1*U(U)><L,1*U(U)>m,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Double)
                   (w2 :: GHC.Types.Double) ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.># 0# y of lwild {
                   DEFAULT
                   -> let {
                        lvl48 :: GHC.Types.Double
                        = case w1 of wild1 { GHC.Types.D# y1 ->
                          case w2 of wild2 { GHC.Types.D# y2 ->
                          case GHC.Prim./##
                                 (GHC.Prim.+## 1.0## y1)
                                 (GHC.Prim.+## 1.0## y2) of wild3 { DEFAULT ->
                          GHC.Types.D# wild3 } } }
                      } in
                      letrec {
                        $wgo2 :: GHC.Prim.Int# -> GHC.Prim.Double# -> GHC.Types.Double
                          <join 2> {- Arity: 2, Strictness: <S,U><S,U>m, Inline: [0] -}
                        = \ (w3 :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Double#) ->
                          case w of wild { GHC.Types.D# x ->
                          case GHC.Prim.<# w3 0# of lwild1 {
                            DEFAULT
                            -> case w3 of wild1 {
                                 DEFAULT
                                 -> case lvl48 of ww2 { GHC.Types.D# ww3 ->
                                    case Main.$wf ww3 wild1 of ww4 { DEFAULT ->
                                    case GHC.Prim.==# wild1 y of lwild2 {
                                      DEFAULT
                                      -> $wgo2
                                           (GHC.Prim.+# wild1 1#)
                                           (GHC.Prim.+## ww1 (GHC.Prim.*## x ww4))
                                      1#
                                      -> GHC.Types.D# (GHC.Prim.+## ww1 (GHC.Prim.*## x ww4)) } } }
                                 0#
                                 -> case y of wild2 {
                                      DEFAULT -> $wgo2 1# (GHC.Prim.+## ww1 x)
                                      0# -> GHC.Types.D# (GHC.Prim.+## ww1 x) } }
                            1# -> Main.$s^1 } }
                      } in
                      $wgo2 0# 0.0##
                   1# -> Main.gordon9 }) -}
a8715d30b41a084e455c28a9010cf8fe
  $wf :: GHC.Prim.Double# -> GHC.Prim.Int# -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [0] -}
dec68c82d6b61d0e2ba06fd9c25a86ac
  $wgrow :: (node -> [node]) -> node -> (# node, [Main.Tree node] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,U>,
     Inline: [0] -}
b8ac82fef9fce454c75f76ca7bc3c9d9
  $wlvl ::
    GHC.Prim.Int# -> GHC.Types.Int -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 let {
                   z :: [(GHC.Types.Int, GHC.Types.Int)]
                   = case ww1 of ww2 { GHC.Types.I# ww3 ->
                     let {
                       ww4 :: GHC.Types.Int = GHC.Types.I# ww
                     } in
                     letrec {
                       go :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [GHC.Types.Int]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int)
                           : y ys
                           -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) (ww4, y) (go ys) }
                     } in
                     go (Test.QuickCheck.Arbitrary.$w$sshrinkIntegral ww3) }
                 } in
                 letrec {
                   go :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) (y, ww1) (go ys) }
                 } in
                 go (Test.QuickCheck.Arbitrary.$w$sshrinkIntegral ww)) -}
c272c53ae637e727174335b8f2e94f67
  $wlvl1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#) ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ (GHC.Types.Int, GHC.Types.Int)
                   Main.$s$fTestable(->)15
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <(GHC.Types.Int, GHC.Types.Int)>_R))
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
4c69c5c809b995fdba9fc65b0aec2704
  $wnsub :: Main.Form -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
654b716554e1db9be37b1f64191b9d05
  $wquickCheckGordon ::
    (GHC.Types.Double
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Types.Double)
    -> GHC.Prim.Double#
    -> GHC.Types.Int
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(C1(C1(C1(U(U)))))><S,U><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double
                         -> GHC.Types.Int
                         -> GHC.Types.Double
                         -> GHC.Types.Double
                         -> GHC.Types.Double)
                   (ww :: GHC.Prim.Double#)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Double)
                   (w3 :: GHC.Types.Double) ->
                 case GHC.Prim.>=## ww 0.0## of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case w1 of wild { GHC.Types.I# x ->
                      case GHC.Prim.>=# x 0# of lwild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case w2 of wild1 { GHC.Types.D# x1 ->
                           case GHC.Prim.>=## x1 0.0## of lwild2 {
                             DEFAULT -> GHC.Types.True
                             1#
                             -> case w3 of wild2 { GHC.Types.D# x2 ->
                                case GHC.Prim.>=## x2 0.0## of lwild3 {
                                  DEFAULT -> GHC.Types.True
                                  1#
                                  -> case GHC.Prim.<=## x1 x2 of lwild4 {
                                       DEFAULT -> GHC.Types.True
                                       1#
                                       -> case w (GHC.Types.D# ww)
                                                 wild
                                                 wild1
                                                 wild2 of wild3 { GHC.Types.D# x3 ->
                                          GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.>=## x3 0.0##) } } } } } } } } }) -}
ff86941b3e6b710b9488e17e5844eb1f
  $wstep611 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> a -> a -> [(a, a)]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,1*C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (ww :: a)
                   (ww1 :: a) ->
                 case GHC.Classes.<=
                        @ a
                        w
                        (GHC.Num.+ @ a w1 ww ww1)
                        (GHC.Num.+
                           @ a
                           w1
                           (GHC.Num.fromInteger @ a w1 Main.step1)
                           w2) of wild {
                   GHC.Types.False -> GHC.Types.[] @ (a, a)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ (a, a)
                        (GHC.Num.+ @ a w1 ww ww1, ww)
                        (GHC.Types.:
                           @ (a, a)
                           (ww, GHC.Num.+ @ a w1 ww ww1)
                           (GHC.Types.[] @ (a, a))) }) -}
4b7490c29c0b23df5ccef04856299a23
  $wtree ::
    (GHC.Classes.Ord a, GHC.Num.Num a) =>
    a -> (# (a, a), [Main.Tree (a, a)] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a) ->
                 Main.$wgrow
                   @ (a, a)
                   (Main.step611 @ a w w1 w2)
                   (GHC.Num.fromInteger @ a w1 Main.tree2,
                    GHC.Num.fromInteger @ a w1 Main.tree1)) -}
72e7d7815f6534f0ab8726617aed5613
  (-->) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (p2 :: GHC.Types.Bool) (q2 :: GHC.Types.Bool) ->
                 case p2 of wild {
                   GHC.Types.False -> GHC.Types.True GHC.Types.True -> q2 }) -}
e447f9c18d4c9157d2f5711c5cbca4a2
  newtype BoundedNumber = BoundedNumber GHC.Types.Int
9000eb4aa3cd62dbc352b5c1a7d2af70
  newtype BoundedNumberAlt = BoundedNumberAlt GHC.Types.Int
7f3962d1bd040eae05a691575220f6ab
  data Form
    = Prop Main.Name
    | Neg Main.Form
    | Cnj [Main.Form]
    | Dsj [Main.Form]
    | Impl Main.Form Main.Form
    | Equiv Main.Form Main.Form
827bc82274996275a3c8460b1e024af0
  newtype LargeNumber = LargeNumber GHC.Types.Int
f11fed1d81a023fc4a77097ab7bfdfd6
  type Name = GHC.Types.Int
6db2207de780f3b107b58c494658c540
  type Rel a = [(a, a)]
87342d69815fc8ca5c7bc9933326b663
  data Tree a = T a [Main.Tree a]
737565f69c8890c628d8677c1182bc35
  form0 :: Main.Form
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Main.Cnj Main.form4) -}
7d2458a9be794921ab335a2fc327d02d
  form1 :: Main.Form
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Main.Equiv Main.form9 Main.form7) -}
14252716fd2546fe8406190c90089ce3
  form10 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.form6 Main.form8) -}
ca393d210911ad5807cdb5ed143d8f1f
  form11 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.p Main.r) -}
e9ef4587c2fe7617d3791e9ef4fc7527
  form12 :: Main.Form
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Main.Cnj Main.form13) -}
8521747a3117eff77659a285c9cb4d72
  form13 :: [Main.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Form Main.form9 Main.form14) -}
90dc5d004debf8ea708b9a7a32bb80a4
  form14 :: [Main.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Main.Form
                   Main.form15
                   (GHC.Types.[] @ Main.Form)) -}
064f2831825227cb9c9a18294cfaa12d
  form15 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.q Main.r) -}
3ba7b80624e27f5b55ff9d7991de71cf
  form2 :: Main.Form
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Main.Equiv Main.form9 Main.form10) -}
ce1a9ef50ad833975b43b67c219b21a0
  form3 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.form12 Main.form11) -}
199925b8a621f0809046cca70bb3d9f0
  form4 :: [Main.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Form Main.p Main.form5) -}
902c0e75d8dcb652e61a17d6077e3256
  form5 :: [Main.Form]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Main.Form
                   Main.form6
                   (GHC.Types.[] @ Main.Form)) -}
70fb3a990169d3334b8c737c95121abb
  form6 :: Main.Form
  {- HasNoCafRefs, Strictness: m2, Unfolding: (Main.Neg Main.p) -}
f89395ea099e999184b53e34e5c27aea
  form7 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.form8 Main.form6) -}
2a9f6aa13bf1d0ee96a1b31997fc2201
  form8 :: Main.Form
  {- HasNoCafRefs, Strictness: m2, Unfolding: (Main.Neg Main.q) -}
fd170988a0248dcd6039043c2933d2db
  form9 :: Main.Form
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Main.Impl Main.p Main.q) -}
03002b5d0f5461fe591009aa137b6552
  givenRelation ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> Test.QuickCheck.Modifiers.Positive GHC.Types.Int
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, Strictness: <S,1*U><L,U(U)>,
     Unfolding: (\ (set :: [(GHC.Types.Int, GHC.Types.Int)])
                   (ds :: Test.QuickCheck.Modifiers.Positive GHC.Types.Int) ->
                 letrec {
                   go :: [(GHC.Types.Int, GHC.Types.Int)]
                         -> [(GHC.Types.Int, GHC.Types.Int)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                     case ds1 of wild {
                       [] -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int)
                       : y ys
                       -> case y of wild1 { (,) x y1 ->
                          case x of wild2 { GHC.Types.I# x1 ->
                          case ds
                                 `cast`
                               (Test.QuickCheck.Modifiers.N:Positive[0]
                                    <GHC.Types.Int>_R) of ww { GHC.Types.I# ww1 ->
                          case ww1 of wild3 {
                            DEFAULT
                            -> case y1 of wild4 { GHC.Types.I# x2 ->
                               case GHC.Classes.modInt# x2 wild3 of ww2 { DEFAULT ->
                               case GHC.Prim.==# x1 ww2 of lwild {
                                 DEFAULT -> go ys
                                 1#
                                 -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) wild1 (go ys) } } }
                            -1#
                            -> case x1 of wild4 {
                                 DEFAULT -> go ys
                                 0# -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) wild1 (go ys) }
                            0#
                            -> case GHC.Real.divZeroError
                               ret_ty [(GHC.Types.Int, GHC.Types.Int)]
                               of {} } } } } }
                 } in
                 go set) -}
44ddfbac1233a4468c2a71a73f675d6d
  gordon1 ::
    (GHC.Real.Fractional a, GHC.Real.Integral b) =>
    a -> b -> a -> a -> a
  {- Arity: 6,
     Strictness: <S(LC(C(S))LL),U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dIntegral :: GHC.Real.Integral b)
                   (eta :: a)
                   (eta1 :: b)
                   (eta2 :: a)
                   (eta3 :: a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (GHC.Num.*
                      @ a
                      $dNum
                      eta
                      (GHC.Num.-
                         @ a
                         $dNum
                         (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                         (GHC.Real.^
                            @ a
                            @ b
                            $dNum
                            $dIntegral
                            (GHC.Real./
                               @ a
                               $dFractional
                               (GHC.Num.+
                                  @ a
                                  $dNum
                                  (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                                  eta2)
                               (GHC.Num.+
                                  @ a
                                  $dNum
                                  (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                                  eta3))
                            eta1)))
                   (GHC.Num.-
                      @ a
                      $dNum
                      (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                      (GHC.Real./
                         @ a
                         $dFractional
                         (GHC.Num.+
                            @ a
                            $dNum
                            (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                            eta2)
                         (GHC.Num.+
                            @ a
                            $dNum
                            (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                            eta3)))) -}
4103c5fc1e348e7bc033049d6c4f0237
  gordon2 ::
    (GHC.Real.Integral b, GHC.Real.Fractional a) =>
    a -> b -> a -> a -> a
  {- Arity: 6,
     Strictness: <L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><S(S(LLC(C(S))LLLL)LLL),U(1*U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dIntegral :: GHC.Real.Integral b)
                   ($dFractional :: GHC.Real.Fractional a)
                   (eta :: a)
                   (eta1 :: b)
                   (eta2 :: a)
                   (eta3 :: a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Num.*
                   @ a
                   $dNum
                   eta
                   (let {
                      lvl48 :: a
                      = GHC.Real./
                          @ a
                          $dFractional
                          (GHC.Num.+
                             @ a
                             $dNum
                             (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                             eta2)
                          (GHC.Num.+
                             @ a
                             $dNum
                             (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                             eta3)
                    } in
                    letrec {
                      go :: [b] -> a -> a
                        <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                      = \ (ds :: [b]) (eta4 :: a) ->
                        case ds of wild {
                          [] -> eta4
                          : y ys
                          -> go
                               ys
                               (GHC.Num.+
                                  @ a
                                  $dNum
                                  eta4
                                  (GHC.Real.^ @ a @ b $dNum $dIntegral lvl48 y)) }
                    } in
                    go
                      (GHC.Enum.enumFromTo
                         @ b
                         (GHC.Real.$p2Integral @ b $dIntegral)
                         (GHC.Num.fromInteger
                            @ b
                            (GHC.Real.$p1Real @ b (GHC.Real.$p1Integral @ b $dIntegral))
                            Main.gordon7)
                         eta1)
                      (GHC.Num.fromInteger @ a $dNum Main.gordon8))) -}
21f2d462af2264e3dae089ff9b465ef4
  gordon3 ::
    (GHC.Real.Fractional a, GHC.Real.Integral b) =>
    a -> b -> a -> a -> a
  {- Arity: 6,
     Strictness: <S(S(LLC(C(S))LLLL)LLL),U(1*U(C(C1(U)),C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dIntegral :: GHC.Real.Integral b)
                   (eta :: a)
                   (eta1 :: b)
                   (eta2 :: a)
                   (eta3 :: a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 GHC.Num.*
                   @ a
                   $dNum
                   (GHC.Real./
                      @ a
                      $dFractional
                      (GHC.Num.*
                         @ a
                         $dNum
                         eta
                         (GHC.Num.-
                            @ a
                            $dNum
                            (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                            (GHC.Real.^
                               @ a
                               @ b
                               $dNum
                               $dIntegral
                               (GHC.Real./
                                  @ a
                                  $dFractional
                                  (GHC.Num.+
                                     @ a
                                     $dNum
                                     (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                                     eta2)
                                  (GHC.Num.+
                                     @ a
                                     $dNum
                                     (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                                     eta3))
                               eta1)))
                      (GHC.Num.- @ a $dNum eta3 eta2))
                   (GHC.Num.+
                      @ a
                      $dNum
                      (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                      eta2)) -}
101d541ca7423fe711c1537a2597d3c9
  gordon4 ::
    (GHC.Real.Integral b, GHC.Real.Fractional a) =>
    a -> b -> a -> a -> a
  {- Arity: 6,
     Strictness: <S(LS(LLLLLLC(C(S))L)LLLLLLL),U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(1*U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   ($dIntegral :: GHC.Real.Integral b)
                   ($dFractional :: GHC.Real.Fractional a)
                   (eta :: a)
                   (eta1 :: b)
                   (eta2 :: a)
                   (eta3 :: a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 let {
                   lvl48 :: a
                   = GHC.Real./
                       @ a
                       $dFractional
                       (GHC.Num.+
                          @ a
                          $dNum
                          (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                          eta2)
                       (GHC.Num.+
                          @ a
                          $dNum
                          (GHC.Num.fromInteger @ a $dNum Main.gordon7)
                          eta3)
                 } in
                 let {
                   $dNum1 :: GHC.Real.Real b = GHC.Real.$p1Integral @ b $dIntegral
                 } in
                 let {
                   $dNum2 :: GHC.Num.Num b = GHC.Real.$p1Real @ b $dNum1
                 } in
                 letrec {
                   go :: [b] -> a -> a
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [b]) (eta4 :: a) ->
                     case ds of wild {
                       [] -> eta4
                       : y ys
                       -> go
                            ys
                            (GHC.Num.+
                               @ a
                               $dNum
                               eta4
                               (GHC.Num.*
                                  @ a
                                  $dNum
                                  eta
                                  (GHC.Real.^ @ a @ b $dNum $dIntegral lvl48 y))) }
                 } in
                 go
                   (GHC.Enum.enumFromTo
                      @ b
                      (GHC.Real.$p2Integral @ b $dIntegral)
                      (GHC.Num.fromInteger @ b $dNum2 Main.gordon8)
                      (GHC.Num.-
                         @ b
                         $dNum2
                         eta1
                         (GHC.Num.fromInteger @ b $dNum2 Main.gordon7)))
                   (GHC.Num.fromInteger @ a $dNum Main.gordon8)) -}
6422860ecf4787fe71451d2003e2364d
  gordon7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
61223bd8a23e71338281158a27ee6471
  gordon8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
4e986786b50534307b89c3a9b90fe8c2
  gordon9 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.0##) -}
d15ee4ccf6e13f71f65c6b468c7ebb9d
  grow :: (node -> [node]) -> node -> Main.Tree node
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ node (w :: node -> [node]) (w1 :: node) ->
                 case Main.$wgrow @ node w w1 of ww { (#,#) ww1 ww2 ->
                 Main.T @ node ww1 ww2 }) -}
8e13b951c65d27625294cd34cea14d9a
  isSerial :: GHC.Classes.Eq a => [a] -> Main.Rel a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (a, a)
                   = GHC.Classes.$fEq(,) @ a @ a $dEq $dEq
                 } in
                 (\ (s :: [a]) (r2 :: Main.Rel a) ->
                  letrec {
                    go :: [a] -> Data.Semigroup.Internal.All
                      <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                    = \ (ds :: [a]) ->
                      case ds of wild {
                        []
                        -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                        : y ys
                        -> let {
                             exit :: Data.Semigroup.Internal.All <join 0> = go ys
                           } in
                           letrec {
                             go1 :: [a] -> Data.Semigroup.Internal.All
                               <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [a]) ->
                               case ds1 of wild1 {
                                 []
                                 -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                                 : y1 ys1
                                 -> case GHC.List.elem @ (a, a) $dEq1 (y, y1) r2 of wild2 {
                                      GHC.Types.False -> go1 ys1 GHC.Types.True -> exit } }
                           } in
                           go1 s }
                  } in
                  go s)
                   `cast`
                 (<[a]>_R
                  ->_R <Main.Rel a>_R
                  ->_R Data.Semigroup.Internal.N:All[0])) -}
6ce96810a37b5c1ba0da354f7748b237
  isSerial1 ::
    [GHC.Types.Int]
    -> Main.Rel GHC.Types.Int -> Data.Semigroup.Internal.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (s :: [GHC.Types.Int])
                   (r2 :: Main.Rel GHC.Types.Int) ->
                 letrec {
                   go :: [GHC.Types.Int] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [GHC.Types.Int] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Types.Int]) ->
                              case ds1 of wild1 {
                                []
                                -> GHC.Types.False `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                                : y1 ys1
                                -> case GHC.List.elem
                                          @ (GHC.Types.Int, GHC.Types.Int)
                                          Main.$s$fEq(,)
                                          (y, y1)
                                          r2 of wild2 {
                                     GHC.Types.False -> go1 ys1 GHC.Types.True -> exit } }
                          } in
                          go1 s }
                 } in
                 go s) -}
b4f9ae97a091b232a88173a93240314d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
529073e95d7e97cca9b9c5c633464b51
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
2ae627898cff160a4ab35ad5461925fa
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
0f1cc2b0b980cea3ed16ae646b000a55
  nsub :: Main.Form -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Form) ->
                 case Main.$wnsub w of ww { DEFAULT -> GHC.Types.I# ww }) -}
67e7322f369d06dcfdba33d1e3adad93
  p :: Main.Form
  {- HasNoCafRefs, Strictness: m1, Unfolding: (Main.Prop Main.p1) -}
a81be383b30cfd11382513d20ed4e02f
  p1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
29ad2e709d052d9cf5051117782624ee
  propEqualSize :: Main.Form -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (f :: Main.Form) ->
                 case GHC.List.$wlenAcc
                        @ Main.Form
                        (Main.sub f) `cast` (SetOrd.N:Set[0] <Main.Form>_N)
                        0# of ww2 { DEFAULT ->
                 case Main.$wnsub f of ww { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 ww) } }) -}
9eb904e89c09199147fa130b637c1736
  propExample ::
    Test.QuickCheck.Modifiers.NonNegative GHC.Types.Int
    -> Test.QuickCheck.Modifiers.Positive GHC.Types.Int
    -> Main.BoundedNumber
    -> Main.LargeNumber
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Unfolding: (\ (ds :: Test.QuickCheck.Modifiers.NonNegative
                            GHC.Types.Int)
                   (ds1 :: Test.QuickCheck.Modifiers.Positive GHC.Types.Int)
                   (ds2 :: Main.BoundedNumber)
                   (ds3 :: Main.LargeNumber) ->
                 Debug.Trace.trace
                   @ GHC.Types.Bool
                   (GHC.CString.unpackAppendCString#
                      Main.propExample4
                      (case ds
                              `cast`
                            (Test.QuickCheck.Modifiers.N:NonNegative[0]
                                 <GHC.Types.Int>_R) of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww3
                              (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Base.++_$s++
                         @ GHC.Types.Char
                         (GHC.CString.unpackAppendCString#
                            Main.propExample3
                            (case ds1
                                    `cast`
                                  (Test.QuickCheck.Modifiers.N:Positive[0]
                                       <GHC.Types.Int>_R) of ww1 { GHC.Types.I# ww8 ->
                             case GHC.Show.$wshowSignedInt
                                    0#
                                    ww8
                                    (GHC.Types.[] @ GHC.Types.Char) of ww9 { (#,#) ww10 ww11 ->
                             GHC.Base.++_$s++
                               @ GHC.Types.Char
                               (GHC.CString.unpackAppendCString#
                                  Main.propExample2
                                  (case ds2
                                          `cast`
                                        (Main.N:BoundedNumber[0]) of ww12 { GHC.Types.I# ww13 ->
                                   case GHC.Show.$wshowSignedInt
                                          0#
                                          ww13
                                          (GHC.Types.[]
                                             @ GHC.Types.Char) of ww14 { (#,#) ww15 ww16 ->
                                   GHC.Base.++_$s++
                                     @ GHC.Types.Char
                                     (GHC.CString.unpackAppendCString#
                                        Main.propExample1
                                        (case ds3
                                                `cast`
                                              (Main.N:LargeNumber[0]) of ww17 { GHC.Types.I# ww18 ->
                                         case GHC.Show.$wshowSignedInt
                                                0#
                                                ww18
                                                (GHC.Types.[]
                                                   @ GHC.Types.Char) of ww19 { (#,#) ww20 ww21 ->
                                         GHC.Types.: @ GHC.Types.Char ww20 ww21 } }))
                                     ww15
                                     ww16 } }))
                               ww10
                               ww11 } }))
                         ww5
                         ww6 } }))
                   GHC.Types.True) -}
4a4746899ff1e3648cf3841fb8e9d018
  propExample1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", LargeNumber l = "#) -}
71bc3ed1ab52b457084a2bbdb535a6bb
  propExample2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", BoundedNumber i = "#) -}
f3622d627098a3505bffa53e22b4f484
  propExample3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (", Positive k = "#) -}
7e6c575d9c3a4aecf94c88c8d494a4c1
  propExample4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NonNegative n = "#) -}
6dd8d3b975b8159f2b536aa635a1ef9c
  propIfNoAtomSetSizeMoreThanOne :: Main.Form -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Main.Form) ->
                 case ds of wild {
                   DEFAULT
                   -> case GHC.List.$wlenAcc
                             @ Main.Form
                             (Main.sub wild) `cast` (SetOrd.N:Set[0] <Main.Form>_N)
                             0# of ww2 { DEFAULT ->
                      GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># ww2 1#) }
                   Main.Prop x -> GHC.Types.True }) -}
851d88992aa0c4b78da61e7023e68ccf
  propNotSerialIfRelationHasLowerSize ::
    [GHC.Types.Int] -> Main.Rel GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ (s :: [GHC.Types.Int])
                   (r2 :: Main.Rel GHC.Types.Int) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Types.Int, GHC.Types.Int)
                        r2
                        0# of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int s 0# of ww1 { DEFAULT ->
                 case GHC.Prim.<# ww2 ww1 of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case (Main.isSerial1 s r2)
                             `cast`
                           (Data.Semigroup.Internal.N:All[0]) of wild {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
08dd39cefe50ce52097dcc431cdda8eb
  propReflexiveAlwaysSerial :: [GHC.Types.Int] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.propReflexiveAlwaysSerial1
                  `cast`
                (<[GHC.Types.Int]>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
9251eb6eeee5461cfcc0e65f33a4e8a2
  propReflexiveAlwaysSerial1 ::
    [GHC.Types.Int] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (s :: [GHC.Types.Int]) ->
                 Main.isSerial1 s (Main.propReflexiveAlwaysSerial_go s)) -}
dffc9cadeae8505b0c8bce080cada897
  propReflexiveAlwaysSerial_go ::
    [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7f451742e0f31374b8a60af7805035d3
  propSetNotEmpty :: Main.Form -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (f :: Main.Form) ->
                 case GHC.List.$wlenAcc
                        @ Main.Form
                        (Main.sub f) `cast` (SetOrd.N:Set[0] <Main.Form>_N)
                        0# of ww2 {
                   DEFAULT -> GHC.Types.True 0# -> GHC.Types.False }) -}
aae6f60c061f772397465d0de97205ff
  q :: Main.Form
  {- HasNoCafRefs, Strictness: m1, Unfolding: (Main.Prop Main.q1) -}
e9e57489b703bcdea3f0963045ddd3a1
  q1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
6833e4c639735bd47c4b54417e837e45
  quickCheckGordon ::
    (GHC.Types.Double
     -> GHC.Types.Int
     -> GHC.Types.Double
     -> GHC.Types.Double
     -> GHC.Types.Double)
    -> GHC.Types.Double
    -> GHC.Types.Int
    -> GHC.Types.Double
    -> GHC.Types.Double
    -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*C1(C1(C1(C1(U(U)))))><S(S),1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: GHC.Types.Double
                         -> GHC.Types.Int
                         -> GHC.Types.Double
                         -> GHC.Types.Double
                         -> GHC.Types.Double)
                   (w1 :: GHC.Types.Double)
                   (w2 :: GHC.Types.Int)
                   (w3 :: GHC.Types.Double)
                   (w4 :: GHC.Types.Double) ->
                 case w1 of ww { GHC.Types.D# ww1 ->
                 Main.$wquickCheckGordon w ww1 w2 w3 w4 }) -}
e5d97fe59d2f8dd6ee3aaee758297ed0
  r :: Main.Form
  {- HasNoCafRefs, Strictness: m1, Unfolding: (Main.Prop Main.r1) -}
0bc45fc5229e0ae6c5d62be36aa5caab
  r1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
c3154b5fa085e35f990113cab772df9e
  setLength :: GHC.Classes.Eq a => SetOrd.Set a -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dEq :: GHC.Classes.Eq a) (ds :: SetOrd.Set a) ->
                 case GHC.List.$wlenAcc
                        @ a
                        ds `cast` (SetOrd.N:Set[0] <a>_N)
                        0# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 }) -}
a0a689bdfff7c190b55619fd4624a8a7
  showLst :: [Main.Form] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Main.Form]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : f fs
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        (Main.$fShowForm_$cshow f)
                        (Main.showRest fs) }) -}
78fdf8469f44e3cb964fa7a89e88eaf6
  showRest :: [Main.Form] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
e235b941bcabda3b3405327cefd7b8d2
  step1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (60) -}
f2ca44e081d8406b8e5b52c842c7f65a
  step611 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> (a, a) -> [(a, a)]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (w3 :: (a, a)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 Main.$wstep611 @ a w w1 w2 ww1 ww2 }) -}
6c3412c5ebae2c21216bda5d6d3a9500
  sub :: Main.Form -> SetOrd.Set Main.Form
  {- Arity: 1, Strictness: <S,1*U> -}
2eec0176594d01785b22055db4377427
  tree :: (GHC.Classes.Ord a, GHC.Num.Num a) => a -> Main.Tree (a, a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: GHC.Num.Num a) (w2 :: a) ->
                 case Main.$wtree @ a w w1 w2 of ww { (#,#) ww1 ww2 ->
                 Main.T @ (a, a) ww1 ww2 }) -}
aae60a0b773b8e6f892d3ad3b501382c
  tree1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (11) -}
51ef94ffe7b3a8be365893bf74f4fc4b
  tree2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (6) -}
instance Test.QuickCheck.Arbitrary.Arbitrary [Main.BoundedNumber]
  = Main.$fArbitraryBoundedNumber
instance Test.QuickCheck.Arbitrary.Arbitrary [Main.BoundedNumberAlt]
  = Main.$fArbitraryBoundedNumberAlt
instance Test.QuickCheck.Arbitrary.Arbitrary [Main.LargeNumber]
  = Main.$fArbitraryLargeNumber
instance GHC.Classes.Eq [Main.BoundedNumber]
  = Main.$fEqBoundedNumber
instance GHC.Classes.Eq [Main.BoundedNumberAlt]
  = Main.$fEqBoundedNumberAlt
instance GHC.Classes.Eq [Main.Form] = Main.$fEqForm
instance GHC.Classes.Eq [Main.LargeNumber] = Main.$fEqLargeNumber
instance GHC.Classes.Eq [Main.Tree] = Main.$fEqTree
instance GHC.Classes.Ord [Main.BoundedNumber]
  = Main.$fOrdBoundedNumber
instance GHC.Classes.Ord [Main.BoundedNumberAlt]
  = Main.$fOrdBoundedNumberAlt
instance GHC.Classes.Ord [Main.Form] = Main.$fOrdForm
instance GHC.Classes.Ord [Main.LargeNumber] = Main.$fOrdLargeNumber
instance GHC.Classes.Ord [Main.Tree] = Main.$fOrdTree
instance GHC.Show.Show [Main.BoundedNumber]
  = Main.$fShowBoundedNumber
instance GHC.Show.Show [Main.BoundedNumberAlt]
  = Main.$fShowBoundedNumberAlt
instance GHC.Show.Show [Main.Form] = Main.$fShowForm
instance GHC.Show.Show [Main.LargeNumber] = Main.$fShowLargeNumber
instance GHC.Show.Show [Main.Tree] = Main.$fShowTree
"SPEC/Main $fArbitraryZipList2 @ Int" [orphan] [0] forall (w :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                  GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitraryZipList2 @ GHC.Types.Int w
  = Main.$s$fArbitraryZipList1
"SPEC/Main $fEq(,) @ Int @ Int" [orphan] forall (v1 :: GHC.Classes.Eq
                                                         GHC.Types.Int)
                                                (v :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int v v1
  = Main.$s$fEq(,)
"SPEC/Main $fEq(,)_$c/= @ Int @ Int" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                 GHC.Types.Int)
                                                     ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Main.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Main $fShow[] @ (Int, Int)" [orphan] forall (v :: GHC.Show.Show
                                                          (GHC.Types.Int, GHC.Types.Int))
  GHC.Show.$fShow[] @ (GHC.Types.Int, GHC.Types.Int) v
  = Main.$s$fShow[]
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

