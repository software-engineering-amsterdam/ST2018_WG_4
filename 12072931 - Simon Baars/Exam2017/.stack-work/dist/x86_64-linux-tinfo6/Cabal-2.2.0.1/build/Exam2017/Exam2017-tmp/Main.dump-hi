
==================== FINAL INTERFACE ====================
2018-10-23 12:08:20.360033713 UTC

interface main:Main 8043
  interface hash: 53077bbff873e7898294212b3faa9852
  ABI hash: 8c7ce8e1d254d465d692927c47b10e1f
  export-list hash: 3035b8781317fe3218fbcd478bc31a4d
  orphan hash: 7208e519fbaa7bc4b91da06234911a02
  flag hash: 30ca4411d3c644939f3feae7dc1c6342
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.-->
  Main.coprime
  Main.coprimes
  Main.fGcd
  Main.fctGcd
  Main.grow
  Main.isLinear
  Main.jos
  Main.main
  Main.meeny
  Main.pairs
  Main.probWin1
  Main.probWin2
  Main.probWin3
  Main.propBetween0and1
  Main.propChooseFirstPerson
  Main.propEeny
  Main.propEmptyAndSingletonListLinear
  Main.propFirstElementIsZero
  Main.propILowerThanKLessThanOrEqualToZero
  Main.propList2Equal
  Main.propListEqual
  Main.propMinimalAmountOfPairsWithDifferentElements
  Main.propRelationsBetweenDifferentElements
  Main.propStepCoprimeContainsAllCoprimes
  Main.step1
  Main.step1list
  Main.step2
  Main.stepCoprime
  Main.tree
  Main.tree1
  Main.tree2
  Main.tree2list
  Main.ChanceDouble{Main.ChanceDouble}
  Main.Rel
  Main.Tree{Main.T}
module dependencies:
package dependencies: QuickCheck-2.11.3 array-0.5.2.0
                      base-4.11.1.0* containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      template-haskell-2.13.0.0 tf-random-0.5 time-1.8.0.2
                      transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.11.3:Test.QuickCheck e00d138ee3234e83a31cc3113c8c8ffb
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Arbitrary 749c030890709ce50a65277c8ad56400
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Gen 18d7f741d47ea7234320fe42d69d1321
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Test 5c80e8a0569651177c75db83b77c7ff4
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.List 83dc843e47bfc0c5af51e19c6f3476d5
import  -/  base-4.11.1.0:Data.Maybe 409c3da2b142470b68be39ce1d97a9f7
import  -/  base-4.11.1.0:Data.OldList 1b35aa3c6805ff7c8887a35a866fe006
import  -/  base-4.11.1.0:Data.Tuple 3af66f3ac61ed95ba8a3a3f68ebc5003
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Read b9e6d20d40da8c8a12b566d22e1160e0
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  base-4.11.1.0:System.IO 1c239be44126f7b1ba512ea61300f4dc
import  -/  base-4.11.1.0:Text.ParserCombinators.ReadPrec d0ebf984ed486435a97481288b73febb
import  -/  base-4.11.1.0:Text.Read.Lex f8ad6f9ae74ae325ba69a4fa5c82aaca
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type f3d5169c3d3830854b19f6565b265403
fixities infix 1 -->
210132f57e936b7ca2502686ed789437
  $fArbitraryChanceDouble ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.ChanceDouble
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.ChanceDouble
                  Main.$fArbitraryChanceDouble1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.ChanceDouble>_R))
                  Main.$fArbitraryChanceDouble_$cshrink -}
210132f57e936b7ca2502686ed789437
  $fArbitraryChanceDouble1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.ChanceDouble
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 Main.$w$carbitrary ww1 ww2 ww3 ww4 ww8 } }) -}
3a6bcf5b42e55de9d082a1a3a6174974
  $fArbitraryChanceDouble2 :: GHC.Types.Double -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Double) ->
                 case x of wild { GHC.Types.D# x1 ->
                 case GHC.Prim.>=## x1 0.0## of lwild {
                   DEFAULT -> GHC.Types.False
                   1#
                   -> GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=## x1 1.0##) } }) -}
7f4850c0bb69099a0eede23cba64e04b
  $fArbitraryChanceDouble3 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Double
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 case Test.QuickCheck.Arbitrary.$w$sarbitrarySizedFractional2
                        ww1
                        ww2
                        ww3
                        ww4
                        ww8 of wild { GHC.Types.D# x ->
                 GHC.Types.D# (GHC.Prim.fabsDouble# x) } } }) -}
210132f57e936b7ca2502686ed789437
  $fArbitraryChanceDouble_$cshrink ::
    Main.ChanceDouble -> [Main.ChanceDouble]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.ChanceDouble) ->
                 GHC.Types.[] @ Main.ChanceDouble) -}
210132f57e936b7ca2502686ed789437
  $fEqChanceDouble :: GHC.Classes.Eq Main.ChanceDouble
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.ChanceDouble
                  GHC.Classes.eqDouble
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fEqDouble_$c/=
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R) -}
760db06c5bb12536ac7f23516f7dde21
  $fEqTree :: GHC.Classes.Eq a => GHC.Classes.Eq (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Main.Tree a)
                  (Main.$fEqTree_$c== @ a v)
                  (Main.$fEqTree_$c/= @ a v) -}
760db06c5bb12536ac7f23516f7dde21
  $fEqTree_$c/= ::
    GHC.Classes.Eq a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fEqTree_$c== @ a $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
760db06c5bb12536ac7f23516f7dde21
  $fEqTree_$c== ::
    GHC.Classes.Eq a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
210132f57e936b7ca2502686ed789437
  $fOrdChanceDouble :: GHC.Classes.Ord Main.ChanceDouble
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.ChanceDouble
                  Main.$fEqChanceDouble
                  GHC.Classes.$fOrdDouble_$ccompare
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Ordering>_R)
                  GHC.Classes.$fOrdDouble_$c<
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdDouble_$c<=
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdDouble_$c>
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdDouble_$c>=
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fOrdDouble_$cmax
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0]))
                  GHC.Classes.$fOrdDouble_$cmin
                    `cast`
                  (Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])
                   ->_R Sym (Main.N:ChanceDouble[0])) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree :: GHC.Classes.Ord a => GHC.Classes.Ord (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (Main.Tree a)
                  (Main.$fOrdTree_$cp1Ord @ a v)
                  (Main.$fOrdTree_$ccompare @ a v)
                  (Main.$fOrdTree_$c< @ a v)
                  (Main.$fOrdTree_$c<= @ a v)
                  (\ (a1 :: Main.Tree a) (b :: Main.Tree a) ->
                   Main.$fOrdTree_$c< @ a v b a1)
                  (Main.$fOrdTree_$c>= @ a v)
                  (Main.$fOrdTree_$cmax @ a v)
                  (Main.$fOrdTree_$cmin @ a v) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$c< ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)> -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$c<= ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Main.Tree a)
                   (b :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd b a1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$c>= ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: Main.Tree a)
                   (b :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$ccompare ::
    GHC.Classes.Ord a =>
    Main.Tree a -> Main.Tree a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)> -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$cmax ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> Main.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$cmin ::
    GHC.Classes.Ord a => Main.Tree a -> Main.Tree a -> Main.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U(U,U)><L,U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: Main.Tree a)
                   (y :: Main.Tree a) ->
                 case Main.$fOrdTree_$c< @ a $dOrd y x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
760db06c5bb12536ac7f23516f7dde21
  $fOrdTree_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (Main.Tree a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 Main.$fEqTree @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble :: GHC.Read.Read Main.ChanceDouble
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.ChanceDouble
                  Main.$fReadChanceDouble_$creadsPrec
                  Main.$fReadChanceDouble_$creadList
                  Main.$fReadChanceDouble1
                    `cast`
                  ((<Text.ParserCombinators.ReadPrec.Prec>_R
                    ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                  <Main.ChanceDouble>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     <Main.ChanceDouble>_R))
                  Main.$fReadChanceDouble_$creadListPrec -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Main.ChanceDouble -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2,
     Unfolding: (GHC.Read.$fRead()6
                   @ Main.ChanceDouble
                   Main.$fReadChanceDouble2
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Main.ChanceDouble>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Main.ChanceDouble>_R))) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Main.ChanceDouble -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Main.ChanceDouble -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$creadPrec ww1 @ b w1 }) -}
f89f2a2975fdc53ccda4320e8284dc07
  $fReadChanceDouble3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.$fReadChanceDouble4) -}
52be88adaf10539abaee29e1ac2a3550
  $fReadChanceDouble4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChanceDouble"#) -}
106c1833f6ae712f6ffd939f76ef2b7a
  $fReadChanceDouble5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble6 ::
    Text.ParserCombinators.ReadP.P [Main.ChanceDouble]
  {- Unfolding: ((Main.$fReadChanceDouble_$creadListPrec
                    `cast`
                  (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                       <[Main.ChanceDouble]>_R)
                    GHC.Read.$fRead()8)
                   `cast`
                 (Text.ParserCombinators.ReadP.N:ReadP[0] <[Main.ChanceDouble]>_R)
                   @ [Main.ChanceDouble]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Main.ChanceDouble])) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Main.ChanceDouble]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Main.ChanceDouble]
                   Main.$fReadChanceDouble6) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Main.ChanceDouble]
  {- Unfolding: (GHC.Read.list
                   @ Main.ChanceDouble
                   Main.$fReadChanceDouble1
                     `cast`
                   ((<Text.ParserCombinators.ReadPrec.Prec>_R
                     ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                   <Main.ChanceDouble>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      <Main.ChanceDouble>_R))) -}
210132f57e936b7ca2502686ed789437
  $fReadChanceDouble_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Main.ChanceDouble
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (n :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Main.ChanceDouble
                   (GHC.Read.$fRead()6
                      @ Main.ChanceDouble
                      Main.$fReadChanceDouble2
                        `cast`
                      ((<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Main.ChanceDouble>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                         <Main.ChanceDouble>_R))
                      n
                      @ Main.ChanceDouble
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Main.ChanceDouble))) -}
210132f57e936b7ca2502686ed789437
  $fShowChanceDouble :: GHC.Show.Show Main.ChanceDouble
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.ChanceDouble
                  Main.$fShowChanceDouble_$cshowsPrec
                  Main.$fShowChanceDouble_$cshow
                  Main.$fShowChanceDouble_$cshowList -}
210132f57e936b7ca2502686ed789437
  $fShowChanceDouble1 :: Main.ChanceDouble -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: (\ (w :: Main.ChanceDouble) ->
                 Main.$w$cshowsPrec 0# w) -}
c25faa00cd8a761fa7ecb9e587c20aa6
  $fShowChanceDouble2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Main.$fShowChanceDouble3) -}
101f04c67d124dd92da2ee8df63a80e3
  $fShowChanceDouble3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ChanceDouble "#) -}
210132f57e936b7ca2502686ed789437
  $fShowChanceDouble_$cshow :: Main.ChanceDouble -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: (\ (x :: Main.ChanceDouble) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowChanceDouble2
                   (case x `cast` (Main.N:ChanceDouble[0]) of ww { GHC.Types.D# ww1 ->
                    GHC.Float.$w$sshowSignedFloat
                      GHC.Float.$fShowDouble2
                      Main.$fReadChanceDouble5
                      ww1
                      (GHC.Types.[] @ GHC.Types.Char) })) -}
210132f57e936b7ca2502686ed789437
  $fShowChanceDouble_$cshowList ::
    [Main.ChanceDouble] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.ChanceDouble]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Main.ChanceDouble
                   Main.$fShowChanceDouble1
                   ls
                   s) -}
210132f57e936b7ca2502686ed789437
  $fShowChanceDouble_$cshowsPrec ::
    GHC.Types.Int -> Main.ChanceDouble -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,1*U(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Main.ChanceDouble) ->
                 case w of ww { GHC.Types.I# ww1 -> Main.$w$cshowsPrec ww1 w1 }) -}
760db06c5bb12536ac7f23516f7dde21
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Main.Tree a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Main.Tree a)
                  (Main.$fShowTree_$cshowsPrec @ a v)
                  (Main.$fShowTree_$cshow @ a v)
                  (Main.$fShowTree_$cshowList @ a v) -}
8a2e1ef3cf23b180cf649dea574db704
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
760db06c5bb12536ac7f23516f7dde21
  $fShowTree_$cshow ::
    GHC.Show.Show a => Main.Tree a -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Main.Tree a) ->
                 Main.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   Main.$fShowTree1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
760db06c5bb12536ac7f23516f7dde21
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Main.Tree a] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Main.Tree a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Tree a)
                   (Main.$fShowTree_$cshowsPrec @ a $dShow Main.$fShowTree1)
                   ls
                   s) -}
760db06c5bb12536ac7f23516f7dde21
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Main.Tree a -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Tree a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Main.T ww3 ww4 ->
                 Main.$w$cshowsPrec1 @ a w ww1 ww3 ww4 } }) -}
a231cde55f0a16740b156e8ced22b3d2
  $s$fArbitraryZipList1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w1 :: Test.QuickCheck.Random.QCGen) (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w2 of ww7 { GHC.Types.I# ww8 ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ GHC.Types.Int
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                   ww1
                   ww2
                   ww3
                   ww4
                   ww8 } }) -}
70fe008ecc420925c316daac7946fc07
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  Main.$s$fEq(,)_$s$fEq(,)_$c/= -}
756dde86e72ee1491b06b8712d434422
  $s$fEq(,)1 ::
    GHC.Classes.Eq (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Integer.Type.Integer
                     @ GHC.Integer.Type.Integer
                     GHC.Integer.Type.$fEqInteger
                     GHC.Integer.Type.$fEqInteger)
                  Main.$s$fEq(,)_$s$fEq(,)_$c/=1 -}
d9c29de69e24759049df94d820948480
  $s$fEq(,)_$s$fEq(,)_$c/= ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Types.Int, GHC.Types.Int))
                   (y :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
1b997fd35b0e4b388b266739daae79c7
  $s$fEq(,)_$s$fEq(,)_$c/=1 ::
    (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
                   (y :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                 case x of wild { (,) a1 a2 ->
                 case y of wild1 { (,) b1 b2 ->
                 case GHC.Integer.Type.eqInteger# a1 b1 of wild2 {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case GHC.Integer.Type.eqInteger# a2 b2 of wild3 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } } } }) -}
7c4fcc93f69673d2b27fdc8eada75ea9
  $s$fShow[] :: GHC.Show.Show [(GHC.Types.Int, GHC.Types.Int)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [(GHC.Types.Int, GHC.Types.Int)]
                  (\ (ds :: GHC.Types.Int)
                     (ls :: [(GHC.Types.Int, GHC.Types.Int)])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (GHC.Types.Int, GHC.Types.Int)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        GHC.Show.$fShowInt
                        GHC.Show.$fShowInt
                        GHC.Show.$fShow(,)1)
                     ls
                     s)
                  (\ (x :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                   GHC.Show.showList__
                     @ (GHC.Types.Int, GHC.Types.Int)
                     (GHC.Show.$fShow(,)_$cshowsPrec
                        @ GHC.Types.Int
                        @ GHC.Types.Int
                        GHC.Show.$fShowInt
                        GHC.Show.$fShowInt
                        GHC.Show.$fShow(,)1)
                     x
                     (GHC.Types.[] @ GHC.Types.Char))
                  (\ (ls :: [[(GHC.Types.Int, GHC.Types.Int)]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ [(GHC.Types.Int, GHC.Types.Int)]
                     (\ (ls1 :: [(GHC.Types.Int, GHC.Types.Int)])
                        (s1 :: GHC.Base.String)[OneShot] ->
                      GHC.Show.showList__
                        @ (GHC.Types.Int, GHC.Types.Int)
                        (GHC.Show.$fShow(,)_$cshowsPrec
                           @ GHC.Types.Int
                           @ GHC.Types.Int
                           GHC.Show.$fShowInt
                           GHC.Show.$fShowInt
                           GHC.Show.$fShow(,)1)
                        ls1
                        s1)
                     ls
                     s) -}
832dbf890a687a3e88b4542ded2d538b
  $s$fShow[]_$cshow ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      GHC.Show.$fShow(,)1)
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4ce32088dd1b9a5a65894b1494f22d3b
  $s$fShow[]_$cshowList ::
    [[(GHC.Types.Int, GHC.Types.Int)]] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [[(GHC.Types.Int, GHC.Types.Int)]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ [(GHC.Types.Int, GHC.Types.Int)]
                   (\ (ls1 :: [(GHC.Types.Int, GHC.Types.Int)])
                      (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Show.showList__
                      @ (GHC.Types.Int, GHC.Types.Int)
                      (GHC.Show.$fShow(,)_$cshowsPrec
                         @ GHC.Types.Int
                         @ GHC.Types.Int
                         GHC.Show.$fShowInt
                         GHC.Show.$fShowInt
                         GHC.Show.$fShow(,)1)
                      ls1
                      s1)
                   ls
                   s) -}
137c4bd3d5e12cebb17e2e10f6f96c77
  $s$fTestable(->)10 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 Main.$wlvl1 ww1 ww2 ww3 ww4 ww8 } }) -}
82fcb1bd0f86b821c0ffb54b1466b5c4
  $s$fTestable(->)11 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U(U)>m,
     Unfolding: (\ (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int)[OneShot] ->
                 case eta
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww1
                        ww2
                        ww3
                        ww4 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww11 { System.Random.TF.Gen.TFGen ww12 ww13 ww10 ww14 ww15 ww16 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww12
                        ww13
                        ww10
                        ww14 of ww17 { (#,#) ww18 ww19 ->
                 (Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                    eta1,
                  Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                    ww18 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                    eta1) } } } }) -}
e25156a22f8e49930eb71affc8728f41
  $s$fTestable(->)13 ::
    (GHC.Types.Int -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable2 w ww1 ww2 ww3 ww4 w2 }) -}
15c6ee82492d7c06ad8809e9122f5694
  $s$fTestable(->)16 ::
    (GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Integer.Type.Integer
                         -> Main.ChanceDouble -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable3 w ww1 ww2 ww3 ww4 w2 }) -}
1fd2b04c9f9765f042b2a644edefd22d
  $s$fTestable(->)17 ::
    (Main.ChanceDouble -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.ChanceDouble -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable4 w ww1 ww2 ww3 ww4 w2 }) -}
1e5abdc550c628f8ddd660711ca9cafb
  $s$fTestable(->)4 ::
    (GHC.Integer.Type.Integer -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Integer.Type.Integer -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable w ww1 ww2 ww3 ww4 w2 }) -}
d1eda4b19417ad342f33c0cfa77ca3de
  $s$fTestable(->)7 ::
    ([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable1 w ww1 ww2 ww3 ww4 w2 }) -}
96afde42135d4e249eeb6f8b2bc8bd55
  $s$fTestable(->)8 ::
    [(GHC.Types.Int, GHC.Types.Int)]
    -> [[(GHC.Types.Int, GHC.Types.Int)]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ (GHC.Types.Int, GHC.Types.Int)
                   Main.$s$fTestable(->)9
                   eta) -}
3ce45669a8785b3ac7e07581083365a8
  $s$fTestable(->)9 ::
    (GHC.Types.Int, GHC.Types.Int) -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S(S)L),1*U(1*U(U),U(U))>,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 -> Main.$wlvl ww4 ww2 } }) -}
3ef9b400ceb3134e7bce5e2b6f567b65
  $s^1 :: GHC.Types.Double
  {- Strictness: x -}
60f908c3ae49ba1e6faa200dc661ff57
  $s^2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
571cd0ff7d6cf1a37c3b6b1e80be992e
  $seven1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
4ebea3c0dd70913ddb278827e6c36eff
  $squickCheck11 ::
    (GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Integer.Type.Integer
                         -> GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable6 w ww1 ww2 ww3 ww4 w2 }) -}
eadaeaf0c3a180c19a8737946150268d
  $squickCheck5 ::
    ([GHC.Types.Int]
     -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Int]
                         -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable5 w ww1 ww2 ww3 ww4 w2 }) -}
c797f40c76bf90d9493ae1b096ba0b40
  $squickCheck6 :: [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: [GHC.Types.Int]) ->
                 Test.QuickCheck.Arbitrary.shrinkList
                   @ GHC.Types.Int
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
                   eta) -}
dc56c9867bd218d6b53a23497feec464
  $tc'ChanceDouble :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17351075885363148781##
                   12404281722318483565##
                   Main.$trModule
                   Main.$tc'ChanceDouble2
                   0#
                   Main.$tc'ChanceDouble1) -}
cb08d2679b333525b0513f6a9ed60117
  $tc'ChanceDouble1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
488b40a56ecffbd54338f1b1dd15adac
  $tc'ChanceDouble2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'ChanceDouble3) -}
150ed8c7c23cdd4ffa8400ebd428f488
  $tc'ChanceDouble3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'ChanceDouble"#) -}
82a89cbcc83f0fe4f847c80f8f06c803
  $tc'T :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15564654814037795574##
                   9702549696965301893##
                   Main.$trModule
                   Main.$tc'T2
                   1#
                   Main.$tc'T1) -}
cdea305a07fc7b0ce3b6fa279beed5d1
  $tc'T1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b153c59e0fc12c971d956d3caebbd8d6
  $tc'T2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'T3) -}
3c5909b1a45d9d6f6b666edd1e7deada
  $tc'T3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'T"#) -}
ea323308de061463df945f7dd7be4b91
  $tcChanceDouble :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2089109011729570328##
                   12681059952608428935##
                   Main.$trModule
                   Main.$tcChanceDouble1
                   0#
                   GHC.Types.krep$*) -}
7f3dc67e6591663c6859ab6352484dcf
  $tcChanceDouble1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$fReadChanceDouble4) -}
344ba01ddc47ef15cd34a5a4090287c0
  $tcTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9208051040442588375##
                   2694919957537544827##
                   Main.$trModule
                   Main.$tcTree1
                   0#
                   GHC.Types.krep$*Arr*) -}
2f5ee83cf42ce248da8c643cf86c71f4
  $tcTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTree2) -}
3b8c48e27778354ef7c721b0c45bea2d
  $tcTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Tree"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
210132f57e936b7ca2502686ed789437
  $w$carbitrary ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Main.ChanceDouble
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww8 of ww5 { System.Random.TF.Gen.TFGen ww6 ww10 ww11 ww12 ww13 ww14 ->
                 (Test.QuickCheck.Gen.$wsuchThat
                    @ GHC.Types.Double
                    Main.$fArbitraryChanceDouble3
                      `cast`
                    (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Double>_R))
                    Main.$fArbitraryChanceDouble2
                    ww6
                    ww10
                    ww11
                    ww12
                    ww4)
                   `cast`
                 (Sym (Main.N:ChanceDouble[0])) } }) -}
210132f57e936b7ca2502686ed789437
  $w$creadPrec ::
    GHC.Prim.Int#
    -> forall b.
       (Main.ChanceDouble -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   @ b
                   (w :: Main.ChanceDouble -> Text.ParserCombinators.ReadP.P b) ->
                 case GHC.Prim.<=# ww 10# of lwild {
                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                   1#
                   -> let {
                        lvl118 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl119 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$fReadDouble_$sreadNumber
                                GHC.Read.$fReadDouble_$sconvertFrac
                                Main.$fReadChanceDouble5
                                @ b
                                (\ (a1 :: GHC.Types.Double) ->
                                 w a1 `cast` (Sym (Main.N:ChanceDouble[0])))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ (a3 :: Text.Read.Lex.Lexeme) ->
                             case a3 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a1
                               -> case GHC.Base.eqString a1 Main.$fReadChanceDouble3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl119 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>,
                             Unfolding: InlineRule (1, True, True) (\ (a3 :: ()) -> lvl118) -}
                        = \ (a3 :: ()) -> lvl118
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ (a :: GHC.Base.String) ->
                         Text.ParserCombinators.ReadP.skipSpaces2 a @ b k) }) -}
210132f57e936b7ca2502686ed789437
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Main.ChanceDouble -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Main.ChanceDouble) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case w `cast`
                          (Main.N:ChanceDouble[0]) of ww1 { GHC.Types.D# ww2 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble2
                       Main.$fReadChanceDouble5
                       ww2 }
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Main.$fShowChanceDouble2 (g x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowChanceDouble2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
760db06c5bb12536ac7f23516f7dde21
  $w$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> a -> [Main.Tree a] -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><S,U><L,U><L,U>, Inline: [0] -}
9861d3dbcfdcbfd4431496dd17350fe7
  $w$dTestable ::
    (GHC.Integer.Type.Integer -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Integer.Type.Integer
                   @ GHC.Types.Bool
                   GHC.Show.$fShowInteger
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryInteger_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Integer.Type.Integer>_R))
                   Test.QuickCheck.Arbitrary.shrinkIntegral_$sshrinkIntegral
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
4f621fe33041d830eac0ff0495dc66f0
  $w$dTestable1 ::
    ([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: [(GHC.Types.Int, GHC.Types.Int)]
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ [(GHC.Types.Int, GHC.Types.Int)]
                   @ GHC.Types.Bool
                   Main.$s$fShow[]
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$s$fTestable(->)10
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <[(GHC.Types.Int, GHC.Types.Int)]>_R))
                   Main.$s$fTestable(->)8
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
7a75bce471f99e77cda019f56abde155
  $w$dTestable2 ::
    (GHC.Types.Int -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Types.Int
                   @ GHC.Types.Bool
                   GHC.Show.$fShowInt
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R))
                   Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
b6f4d41d139e84be08fb0edc008a6238
  $w$dTestable3 ::
    (GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer
                         -> Main.ChanceDouble -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Integer.Type.Integer
                   @ (Main.ChanceDouble -> GHC.Types.Bool)
                   GHC.Show.$fShowInteger
                   Main.$s$fTestable(->)17
                     `cast`
                   ((<Main.ChanceDouble -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.ChanceDouble
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryInteger_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Integer.Type.Integer>_R))
                   Test.QuickCheck.Arbitrary.shrinkIntegral_$sshrinkIntegral
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
4bc2baafc94d76bc38a5ffa1214e5e05
  $w$dTestable4 ::
    (Main.ChanceDouble -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.ChanceDouble -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.ChanceDouble
                   @ GHC.Types.Bool
                   Main.$fShowChanceDouble
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryChanceDouble1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.ChanceDouble>_R))
                   Main.$fArbitraryChanceDouble_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
d0bb5279a849352e32a5b8d19aedadfb
  $w$dTestable5 ::
    ([GHC.Types.Int]
     -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Int]
                         -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ [GHC.Types.Int]
                   @ ([(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool)
                   GHC.Show.$fShow[]_$s$fShow[]
                   Main.$s$fTestable(->)7
                     `cast`
                   ((<[(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <[(GHC.Types.Int,
                                                                                                                                       GHC.Types.Int)]
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$s$fArbitraryZipList1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Int]>_R))
                   Main.$squickCheck6
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
3ea6f727fa85eac6515b9b5eced694a2
  $w$dTestable6 ::
    (GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer
                         -> GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ GHC.Integer.Type.Integer
                   @ (GHC.Integer.Type.Integer -> Main.ChanceDouble -> GHC.Types.Bool)
                   GHC.Show.$fShowInteger
                   Main.$s$fTestable(->)16
                     `cast`
                   ((<GHC.Integer.Type.Integer
                      -> Main.ChanceDouble -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <GHC.Integer.Type.Integer
                                                                                                                                     -> Main.ChanceDouble
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Test.QuickCheck.Arbitrary.$fArbitraryInteger_$sarbitrarySizedIntegral
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Integer.Type.Integer>_R))
                   Test.QuickCheck.Arbitrary.shrinkIntegral_$sshrinkIntegral
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
df244092cb09f567f61c198010726549
  $w$s^ ::
    GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Prim.Double#
  {- Arity: 2, Strictness: <L,1*U(U)><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.ltInteger# w1 Main.$s^2 of wild {
                   DEFAULT
                   -> case GHC.Integer.Type.eqInteger# w1 Main.$s^2 of wild1 {
                        DEFAULT -> case w of ww { GHC.Types.D# ww1 -> Main.$wf ww1 w1 }
                        1# -> 1.0## }
                   1# -> case Main.$s^1 ret_ty GHC.Prim.Double# of {} }) -}
4bebbbf6faeece7e45fb9501fd31da11
  $w$sprobWin1 ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Prim.Double#
  {- Arity: 3, Strictness: <S,U><S,U><L,U(U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: GHC.Types.Double) ->
                 case Main.$w$s^
                        w2
                        (GHC.Integer.Type.minusInteger w w1) of ww { DEFAULT ->
                 let {
                   q :: GHC.Types.Double
                   = case w2 of wild1 { GHC.Types.D# y ->
                     GHC.Types.D# (GHC.Prim.-## 1.0## y) }
                 } in
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger w1 Main.coprime1
                 } in
                 let {
                   $j :: GHC.Prim.Double# -> GHC.Prim.Double#
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (ww1 :: GHC.Prim.Double#)[OneShot] ->
                     let {
                       lim1 :: GHC.Integer.Type.Integer
                       = GHC.Integer.Type.minusInteger w Main.coprime1
                     } in
                     letrec {
                       $wgo1 :: GHC.Integer.Type.Integer
                                -> GHC.Prim.Double# -> GHC.Prim.Double#
                         <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                       = \ (w3 :: GHC.Integer.Type.Integer) (ww2 :: GHC.Prim.Double#) ->
                         case GHC.Integer.Type.gtInteger# w3 lim1 of wild {
                           DEFAULT
                           -> case Main.$w$s^ w2 w3 of ww3 { DEFAULT ->
                              case Main.$w$s^
                                     q
                                     (GHC.Integer.Type.minusInteger
                                        (GHC.Integer.Type.minusInteger w w3)
                                        Main.coprime1) of ww4 { DEFAULT ->
                              $wgo1
                                (GHC.Integer.Type.plusInteger w3 Main.coprime1)
                                (GHC.Prim.+## ww2 (GHC.Prim.*## ww3 ww4)) } }
                           1# -> GHC.Prim./## (GHC.Prim.*## ww ww1) ww2 }
                     } in
                     $wgo1 Main.$s^2 0.0##
                 } in
                 letrec {
                   $wgo1 :: GHC.Integer.Type.Integer
                            -> GHC.Prim.Double# -> GHC.Prim.Double#
                     <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                   = \ (w3 :: GHC.Integer.Type.Integer) (ww1 :: GHC.Prim.Double#) ->
                     case GHC.Integer.Type.gtInteger# w3 lim of wild {
                       DEFAULT
                       -> case Main.$w$s^ w2 w3 of ww2 { DEFAULT ->
                          case Main.$w$s^
                                 q
                                 (GHC.Integer.Type.minusInteger
                                    (GHC.Integer.Type.minusInteger w1 w3)
                                    Main.coprime1) of ww3 { DEFAULT ->
                          $wgo1
                            (GHC.Integer.Type.plusInteger w3 Main.coprime1)
                            (GHC.Prim.+## ww1 (GHC.Prim.*## ww2 ww3)) } }
                       1# -> $j ww1 }
                 } in
                 $wgo1 Main.$s^2 0.0## }) -}
51a83ba8c0b2556f7593041942521198
  $w$sprobWin2 ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Prim.Double#
  {- Arity: 3, Strictness: <S,U><S,1*U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: GHC.Types.Double) ->
                 let {
                   r :: GHC.Types.Double
                   = case w2 of wild1 { GHC.Types.D# y ->
                     case GHC.Prim./## (GHC.Prim.-## 1.0## y) y of wild2 { DEFAULT ->
                     GHC.Types.D# wild2 } }
                 } in
                 let {
                   lim :: GHC.Integer.Type.Integer
                   = GHC.Integer.Type.minusInteger w1 Main.coprime1
                 } in
                 let {
                   $j :: GHC.Prim.Double# -> GHC.Prim.Double#
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (ww :: GHC.Prim.Double#)[OneShot] ->
                     let {
                       lim1 :: GHC.Integer.Type.Integer
                       = GHC.Integer.Type.minusInteger w Main.coprime1
                     } in
                     letrec {
                       $wgo1 :: GHC.Integer.Type.Integer
                                -> GHC.Prim.Double# -> GHC.Prim.Double#
                         <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                       = \ (w3 :: GHC.Integer.Type.Integer) (ww1 :: GHC.Prim.Double#) ->
                         case GHC.Integer.Type.gtInteger# w3 lim1 of wild {
                           DEFAULT
                           -> case Main.$w$s^ r w3 of ww2 { DEFAULT ->
                              $wgo1
                                (GHC.Integer.Type.plusInteger w3 Main.coprime1)
                                (GHC.Prim.+## ww1 ww2) }
                           1# -> GHC.Prim./## ww ww1 }
                     } in
                     $wgo1 Main.$s^2 0.0##
                 } in
                 letrec {
                   $wgo1 :: GHC.Integer.Type.Integer
                            -> GHC.Prim.Double# -> GHC.Prim.Double#
                     <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                   = \ (w3 :: GHC.Integer.Type.Integer) (ww :: GHC.Prim.Double#) ->
                     case GHC.Integer.Type.gtInteger# w3 lim of wild {
                       DEFAULT
                       -> case Main.$w$s^ r w3 of ww1 { DEFAULT ->
                          $wgo1
                            (GHC.Integer.Type.plusInteger w3 Main.coprime1)
                            (GHC.Prim.+## ww ww1) }
                       1# -> $j ww }
                 } in
                 $wgo1 Main.$s^2 0.0##) -}
98bc826bfb78af174934f940d0b4721f
  $w$sprobWin3 ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Prim.Double#
  {- Arity: 3, Strictness: <S,U><S,U><L,U(U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: GHC.Types.Double) ->
                 let {
                   q :: GHC.Types.Double
                   = case w2 of wild1 { GHC.Types.D# y ->
                     GHC.Types.D# (GHC.Prim.-## 1.0## y) }
                 } in
                 case Main.$w$s^
                        (case q of wild { GHC.Types.D# x ->
                         case w2 of wild1 { GHC.Types.D# y ->
                         case GHC.Prim./## x y of wild2 { DEFAULT ->
                         GHC.Types.D# wild2 } } })
                        w1 of ww { DEFAULT ->
                 case Main.$w$s^
                        (case q of wild { GHC.Types.D# x ->
                         case w2 of wild1 { GHC.Types.D# y ->
                         case GHC.Prim./## x y of wild2 { DEFAULT ->
                         GHC.Types.D# wild2 } } })
                        w of ww1 { DEFAULT ->
                 GHC.Prim./##
                   (GHC.Prim.-## 1.0## ww)
                   (GHC.Prim.-## 1.0## ww1) } }) -}
1781b525f211f030203d9a5fa27a05d0
  $wf ::
    GHC.Prim.Double# -> GHC.Integer.Type.Integer -> GHC.Prim.Double#
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
fb5133dc24090e5e1a185290b0cb6b10
  $wfctGcd ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> (# GHC.Integer.Type.Integer, GHC.Integer.Type.Integer #)
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [0] -}
29efeee88f22054f4b484822c64d20c4
  $wgo ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [0] -}
0ecb7f694848bae1a8c59d14c2054b30
  $wgrow :: (node -> [node]) -> node -> (# node, [Main.Tree node] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,U>,
     Inline: [0] -}
408d779360f6cd9b56bda90164fb7a90
  $wjos ::
    GHC.Prim.Int# -> GHC.Types.Int -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 3, Strictness: <S,1*U><L,1*U(U)><S,1*U>, Inline: [0] -}
b8ac82fef9fce454c75f76ca7bc3c9d9
  $wlvl ::
    GHC.Prim.Int# -> GHC.Types.Int -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 let {
                   z :: [(GHC.Types.Int, GHC.Types.Int)]
                   = case ww1 of ww2 { GHC.Types.I# ww3 ->
                     let {
                       ww4 :: GHC.Types.Int = GHC.Types.I# ww
                     } in
                     letrec {
                       go :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [GHC.Types.Int]) ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int)
                           : y ys
                           -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) (ww4, y) (go ys) }
                     } in
                     go (Test.QuickCheck.Arbitrary.$w$sshrinkIntegral ww3) }
                 } in
                 letrec {
                   go :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) (y, ww1) (go ys) }
                 } in
                 go (Test.QuickCheck.Arbitrary.$w$sshrinkIntegral ww)) -}
8378b4c5d4325b388feb7caac0b678c5
  $wlvl1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#) ->
                 Test.QuickCheck.Gen.$wlistOf
                   @ (GHC.Types.Int, GHC.Types.Int)
                   Main.$s$fTestable(->)11
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <(GHC.Types.Int, GHC.Types.Int)>_R))
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
08f6df379c7f66d25bf61cf6cccd795e
  $wlvl2 ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Integer.Type.Integer)
                   (ww1 :: GHC.Integer.Type.Integer)
                   (ww2 :: GHC.Integer.Type.Integer)
                   (ww3 :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.compareInteger ww ww2 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ -> GHC.Integer.Type.compareInteger ww1 ww3
                   GHC.Types.GT -> GHC.Types.GT }) -}
5ff93074a3f7936328361148a73d93c2
  $wmeeny ::
    GHC.Types.Int
    -> GHC.Prim.Int# -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U(U)><S,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: [GHC.Base.String]) ->
                 case GHC.List.$wlenAcc @ [GHC.Types.Char] w1 0# of ww2 { DEFAULT ->
                 case Main.$wjos ww2 w (GHC.Prim.+# ww 1#) of ww1 { DEFAULT ->
                 GHC.List.$w!! @ GHC.Base.String w1 ww1 } }) -}
1b8f02e524e63f8e0703b20e45de883e
  $wpropILowerThanKLessThanOrEqualToZero ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                 case GHC.Prim.<# ww1 ww of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case GHC.Prim.>=# ww1 0# of lwild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case Main.$wjos ww Main.$fShowTree1 ww1 of ww2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww2 0#) } } }) -}
f36a4904c9b9d56f73e22e118ff3cebd
  $wpropStepCoprimeContainsAllCoprimes ::
    GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.gtInteger# w Main.$s^2 of wild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case GHC.Integer.Type.integerToInt w of wild1 { DEFAULT ->
                      case Main.$wgrow
                             @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                             (\ (w1 :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                              case w1 of ww { (,) ww1 ww2 -> Main.$wstepCoprime w ww1 ww2 })
                             Main.propList2Equal3 of ww { (#,#) ww1 ww2 ->
                      case GHC.Prim.<# 0# wild1 of lwild {
                        DEFAULT
                        -> GHC.Classes.$fEq[]_$c==
                             @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                             Main.$s$fEq(,)1
                             (GHC.Types.:
                                @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                ww1
                                (Main.propList2Equal1
                                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                   ww2))
                             (GHC.Types.[]
                                @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
                        1#
                        -> GHC.Classes.$fEq[]_$c==
                             @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                             Main.$s$fEq(,)1
                             (GHC.Types.:
                                @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                ww1
                                (Main.propList2Equal1
                                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                   ww2))
                             (GHC.List.$wunsafeTake
                                @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                wild1
                                Main.coprimes) } } } }) -}
f12c3e04059a4b8eff9e99b0eb7c8f7b
  $wstep1 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> a -> a -> [(a, a)]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (ww :: a)
                   (ww1 :: a) ->
                 case GHC.Classes.<= @ a w (GHC.Num.+ @ a w1 ww ww1) w2 of wild {
                   GHC.Types.False -> GHC.Types.[] @ (a, a)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ (a, a)
                        (GHC.Num.+ @ a w1 ww ww1, ww)
                        (GHC.Types.:
                           @ (a, a)
                           (ww, GHC.Num.+ @ a w1 ww ww1)
                           (GHC.Types.[] @ (a, a))) }) -}
dbd7d7658aa26ae6756e08ddfb1fc591
  $wstep1list ::
    GHC.Integer.Type.Integer
    -> (a, b) -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Arity: 2, Strictness: <S,U><L,A>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Integer.Type.Integer)
                   (w1 :: (a, b)) ->
                 letrec {
                   go :: GHC.Integer.Type.Integer
                         -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x :: GHC.Integer.Type.Integer) ->
                     case GHC.Integer.Type.gtInteger# x w of wild {
                       DEFAULT
                       -> let {
                            n :: [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                            = go (GHC.Integer.Type.plusInteger x Main.coprime1)
                          } in
                          letrec {
                            go1 :: GHC.Integer.Type.Integer
                                   -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                              {- Arity: 1, Strictness: <S,U> -}
                            = \ (x1 :: GHC.Integer.Type.Integer) ->
                              case GHC.Integer.Type.gtInteger# x1 w of wild1 {
                                DEFAULT
                                -> case GHC.Integer.Type.eqInteger#
                                          (Main.fGcd x x1)
                                          Main.coprime1 of wild2 {
                                     DEFAULT -> go1 (GHC.Integer.Type.plusInteger x1 Main.coprime1)
                                     1#
                                     -> GHC.Types.:
                                          @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                          (x, x1)
                                          (go1 (GHC.Integer.Type.plusInteger x1 Main.coprime1)) }
                                1# -> n }
                          } in
                          go1 Main.coprime1
                       1#
                       -> GHC.Types.[]
                            @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer) }
                 } in
                 go Main.coprime1) -}
68aa166ef254d9cbfb018f78f6feaf1f
  $wstep2 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> a -> a -> [(a, a)]
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,A)><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (ww :: a)
                   (ww1 :: a) ->
                 case GHC.Classes.<= @ a w (GHC.Num.+ @ a w1 ww ww1) w2 of wild {
                   GHC.Types.False -> GHC.Types.[] @ (a, a)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ (a, a)
                        (GHC.Num.+ @ a w1 ww ww1, ww1)
                        (GHC.Types.:
                           @ (a, a)
                           (ww, GHC.Num.+ @ a w1 ww ww1)
                           (GHC.Types.[] @ (a, a))) }) -}
489696fa98b017988e6bb3f1e5625eb9
  $wstepCoprime ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Arity: 3, Strictness: <S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Integer.Type.Integer)
                   (ww :: GHC.Integer.Type.Integer)
                   (ww1 :: GHC.Integer.Type.Integer) ->
                 let {
                   $j :: GHC.Prim.Int#
                         -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                     <join 1> {- Arity: 1, Strictness: <S,U> -}
                   = \ (i :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Integer.Type.ltInteger#
                            (GHC.Integer.Type.smallInteger i)
                            (GHC.Integer.Type.minusInteger w Main.coprime1) of wild {
                       DEFAULT
                       -> GHC.Types.[]
                            @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                       1#
                       -> GHC.Types.:
                            @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                            (GHC.List.$w!!
                               @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                               Main.coprimes
                               (GHC.Prim.+# i 1#))
                            (GHC.Types.[]
                               @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) }
                 } in
                 letrec {
                   go :: [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                         -> GHC.Prim.Int#
                         -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)])
                       (eta :: GHC.Prim.Int#) ->
                     case ds of wild {
                       []
                       -> case Data.Maybe.fromJust1
                          ret_ty [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
                          of {}
                       : y ys
                       -> case y of ww3 { (,) ww4 ww5 ->
                          case GHC.Integer.Type.eqInteger# ww ww4 of wild1 {
                            DEFAULT -> go ys (GHC.Prim.+# eta 1#)
                            1#
                            -> case GHC.Integer.Type.eqInteger# ww1 ww5 of wild2 {
                                 DEFAULT -> go ys (GHC.Prim.+# eta 1#) 1# -> $j eta } } } }
                 } in
                 go Main.coprimes 0#) -}
69115f8f9d42dc552ec7d5c39940b33e
  $wtree1 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) =>
    a -> (# (a, a), [Main.Tree (a, a)] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a) ->
                 Main.$wgrow
                   @ (a, a)
                   (Main.step1 @ a w w1 w2)
                   (GHC.Num.fromInteger @ a w1 Main.coprime1,
                    GHC.Num.fromInteger @ a w1 Main.coprime1)) -}
86781fbb76baa43e00cef1de9441c85c
  $wtree2 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) =>
    a -> (# (a, a), [Main.Tree (a, a)] #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a) ->
                 Main.$wgrow
                   @ (a, a)
                   (Main.step2 @ a w w1 w2)
                   (GHC.Num.fromInteger @ a w1 Main.coprime1,
                    GHC.Num.fromInteger @ a w1 Main.coprime1)) -}
61b705fcb0cb73ecd2c55bf006808635
  (-->) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: GHC.Types.Bool) (q :: GHC.Types.Bool) ->
                 case p of wild {
                   GHC.Types.False -> GHC.Types.True GHC.Types.True -> q }) -}
210132f57e936b7ca2502686ed789437
  newtype ChanceDouble = ChanceDouble GHC.Types.Double
6db2207de780f3b107b58c494658c540
  type Rel a = [(a, a)]
760db06c5bb12536ac7f23516f7dde21
  data Tree a = T a [Main.Tree a]
bd7f4ccbddae1c4a3b2b14b60ae540e4
  coprime ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Integer.Type.Integer)
                   (m :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.eqInteger#
                        (Main.fGcd n m)
                        Main.coprime1 of wild { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool wild }) -}
ce3e341a8abffa385354c2697d5d6176
  coprime1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
07ce12b40f2308e20efbc743e6fc1e0b
  coprimes :: [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Unfolding: (GHC.List.filter
                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                   Main.coprimes1
                   Main.pairs) -}
8bf044cf5d4d348fb3ad0f1bc3bbfa86
  coprimes1 ::
    (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,U)>,
     Unfolding: (\ (p :: (GHC.Integer.Type.Integer,
                          GHC.Integer.Type.Integer)) ->
                 case p of wild { (,) x ds ->
                 case GHC.Integer.Type.eqInteger#
                        (Main.fGcd x ds)
                        Main.coprime1 of wild1 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1 } }) -}
96dea7629d07bbdcfc59f14dcee34fb6
  fGcd ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
c5ec0178d5c54119b9fbafce874af8b8
  fctGcd ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- Arity: 2, Strictness: <L,U><S,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 case Main.$wfctGcd w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
a05f5a0d542d0d203f271712f026ca05
  grow :: (node -> [node]) -> node -> Main.Tree node
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><L,U>m, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ node (w :: node -> [node]) (w1 :: node) ->
                 case Main.$wgrow @ node w w1 of ww { (#,#) ww1 ww2 ->
                 Main.T @ node ww1 ww2 }) -}
07eabff1bfb337a190bf3f6956dcae21
  isLinear :: GHC.Classes.Eq a => [a] -> Main.Rel a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq (a, a)
                   = GHC.Classes.$fEq(,) @ a @ a $dEq $dEq
                 } in
                 (\ (x :: [a]) (y :: Main.Rel a) ->
                  letrec {
                    go :: [a] -> Data.Semigroup.Internal.All
                      <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                    = \ (ds :: [a]) ->
                      case ds of wild {
                        []
                        -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                        : y1 ys
                        -> let {
                             exit :: Data.Semigroup.Internal.All <join 0> = go ys
                           } in
                           letrec {
                             go1 :: [a] -> Data.Semigroup.Internal.All
                               <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds1 :: [a]) ->
                               case ds1 of wild1 {
                                 [] -> exit
                                 : y2 ys1
                                 -> case GHC.Classes.== @ a $dEq y1 y2 of wild2 {
                                      GHC.Types.False
                                      -> case GHC.List.elem @ (a, a) $dEq1 (y1, y2) y of wild3 {
                                           GHC.Types.False
                                           -> case GHC.List.elem
                                                     @ (a, a)
                                                     $dEq1
                                                     (y2, y1)
                                                     y of wild4 {
                                                GHC.Types.False
                                                -> GHC.Types.False
                                                     `cast`
                                                   (Sym (Data.Semigroup.Internal.N:All[0]))
                                                GHC.Types.True -> go1 ys1 }
                                           GHC.Types.True -> go1 ys1 }
                                      GHC.Types.True -> go1 ys1 } }
                           } in
                           go1 x }
                  } in
                  go x)
                   `cast`
                 (<[a]>_R
                  ->_R <Main.Rel a>_R
                  ->_R Data.Semigroup.Internal.N:All[0])) -}
c77e59dce919bfa5bdc9e6d5018b35ff
  isLinear1 ::
    [GHC.Types.Int]
    -> Main.Rel GHC.Types.Int -> Data.Semigroup.Internal.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (x :: [GHC.Types.Int])
                   (y :: Main.Rel GHC.Types.Int) ->
                 letrec {
                   go :: [GHC.Types.Int] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Int]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y1 ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [GHC.Types.Int] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Types.Int]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y2 ys1
                                -> case y1 of wild2 { GHC.Types.I# x1 ->
                                   case y2 of wild3 { GHC.Types.I# y3 ->
                                   case GHC.Prim.==# x1 y3 of lwild {
                                     DEFAULT
                                     -> case GHC.List.elem
                                               @ (GHC.Types.Int, GHC.Types.Int)
                                               Main.$s$fEq(,)
                                               (wild2, wild3)
                                               y of wild4 {
                                          GHC.Types.False
                                          -> case GHC.List.elem
                                                    @ (GHC.Types.Int, GHC.Types.Int)
                                                    Main.$s$fEq(,)
                                                    (wild3, wild2)
                                                    y of wild5 {
                                               GHC.Types.False
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0]))
                                               GHC.Types.True -> go1 ys1 }
                                          GHC.Types.True -> go1 ys1 }
                                     1# -> go1 ys1 } } } }
                          } in
                          go1 x }
                 } in
                 go x) -}
d5cd3df48eec693eaeb341af4e90619f
  jos ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 3, Strictness: <S(S),1*U(1*U)><L,1*U(U)><S(S),1*U(1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { GHC.Types.I# ww3 ->
                 case Main.$wjos ww1 w1 ww3 of ww4 { DEFAULT ->
                 GHC.Types.I# ww4 } } }) -}
b4f9ae97a091b232a88173a93240314d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
529073e95d7e97cca9b9c5c633464b51
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
2ae627898cff160a4ab35ad5461925fa
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
0595f197342d26e9ef466e71de17fe1d
  meeny ::
    GHC.Types.Int
    -> GHC.Types.Int -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*U(U)><S(S),1*U(U)><S,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Base.String]) ->
                 case w1 of ww { GHC.Types.I# ww1 -> Main.$wmeeny w ww1 w2 }) -}
625b1c98aaf2d710bd4b4a4bfdbbc176
  pairs :: [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Unfolding: (Main.pairs_go Main.coprime1) -}
ffba3b44271c20d6d57615b10f197c6a
  pairs_go ::
    GHC.Integer.Type.Integer
    -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Arity: 1, Strictness: <S,U> -}
728ae239405d530e083926caf22de9f0
  probWin1 ::
    (GHC.Real.Fractional a, GHC.Real.Integral b) => b -> b -> a -> a
  {- Arity: 5,
     Strictness: <S(LC(C(S))LL),U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),1*C1(C1(U)),A,A)><L,U(U(U(A,C(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,A,A,A,A,A,C(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U> -}
5281a93c5015faa7aa4b27c5aa831bc1
  probWin2 ::
    (GHC.Real.Integral b1, GHC.Real.Integral b2,
     GHC.Real.Fractional a) =>
    b2 -> b1 -> a -> a
  {- Arity: 6,
     Strictness: <L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(U(U(A,1*C1(C1(U)),A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),C(C1(U)),C(C1(U)),A,A,A,A,A)><S(LC(C(S))LL),U(1*U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U><L,U><L,U> -}
19c71d2f2e59d637f1b94d103f99c46a
  probWin3 ::
    (GHC.Real.Fractional a, GHC.Real.Integral b1,
     GHC.Real.Integral b2) =>
    b2 -> b1 -> a -> a
  {- Arity: 6,
     Strictness: <S(LC(C(S))LL),U(1*U(A,C(C1(U)),C(C1(U)),A,A,A,C(U)),C(C1(U)),A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   @ b1
                   ($dFractional :: GHC.Real.Fractional a)
                   ($dIntegral :: GHC.Real.Integral b)
                   ($dIntegral1 :: GHC.Real.Integral b1)
                   (eta :: b1)
                   (eta1 :: b)
                   (eta2 :: a) ->
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 let {
                   q :: a
                   = GHC.Num.-
                       @ a
                       $dNum
                       (GHC.Num.fromInteger @ a $dNum Main.coprime1)
                       eta2
                 } in
                 GHC.Real./
                   @ a
                   $dFractional
                   (GHC.Num.-
                      @ a
                      $dNum
                      (GHC.Num.fromInteger @ a $dNum Main.coprime1)
                      (GHC.Real.^
                         @ a
                         @ b
                         $dNum
                         $dIntegral
                         (GHC.Real./ @ a $dFractional q eta2)
                         eta1))
                   (GHC.Num.-
                      @ a
                      $dNum
                      (GHC.Num.fromInteger @ a $dNum Main.coprime1)
                      (GHC.Real.^
                         @ a
                         @ b1
                         $dNum
                         $dIntegral1
                         (GHC.Real./ @ a $dFractional q eta2)
                         eta))) -}
1531dddf336b3a2f40239135c9c3676b
  propBetween0and1 ::
    (GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
     -> GHC.Types.Double
     -> GHC.Types.Double)
    -> GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> Main.ChanceDouble
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*C1(C1(C1(U(U))))><S,U><L,U><L,U>,
     Unfolding: (\ (f :: GHC.Integer.Type.Integer
                         -> GHC.Integer.Type.Integer
                         -> GHC.Types.Double
                         -> GHC.Types.Double)
                   (n :: GHC.Integer.Type.Integer)
                   (i :: GHC.Integer.Type.Integer)
                   (ds :: Main.ChanceDouble) ->
                 case GHC.Integer.Type.geInteger# n Main.coprime1 of wild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case GHC.Integer.Type.geInteger# i Main.$s^2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case GHC.Integer.Type.leInteger# i n of wild2 {
                             DEFAULT -> GHC.Types.True
                             1#
                             -> case f n
                                       i
                                       ds
                                         `cast`
                                       (Main.N:ChanceDouble[0]) of wild3 { GHC.Types.D# x ->
                                case GHC.Prim.>=## x 0.0## of lwild {
                                  DEFAULT -> GHC.Types.False
                                  1#
                                  -> GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<=## x 1.0##) } } } } }) -}
4ece6d58795afba677d5db9b008af152
  propChooseFirstPerson ::
    GHC.Types.Int -> [GHC.Base.String] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ (k :: GHC.Types.Int) (s :: [GHC.Base.String]) ->
                 case s of wild {
                   [] -> GHC.Types.True
                   : ds1 ds2
                   -> case GHC.List.$wlenAcc
                             @ [GHC.Types.Char]
                             wild
                             0# of ww2 { DEFAULT ->
                      case Main.$wjos ww2 k 2# of ww { DEFAULT ->
                      GHC.Base.eqString
                        (GHC.List.$w!! @ GHC.Base.String wild ww)
                        ds1 } } }) -}
b09dea0cd635adb1424c0cf033d5dd51
  propEeny :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wpropILowerThanKLessThanOrEqualToZero ww1 ww3 } }) -}
9544f6cee8aa01da36b0804628f73417
  propEmptyAndSingletonListLinear ::
    [GHC.Types.Int]
    -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (x :: [GHC.Types.Int])
                   (y :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int x 0# of ww2 { DEFAULT ->
                 case GHC.Prim.<# ww2 2# of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> (Main.isLinear1 x y)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) } }) -}
66d0d00ad0390d6bc0d8787100b53601
  propFirstElementIsZero :: GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (k :: GHC.Types.Int) ->
                 case Main.jos
                        Main.propFirstElementIsZero1
                        k
                        Main.$fShowTree1 of wild { GHC.Types.I# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Types.False 0# -> GHC.Types.True } }) -}
8c3f232e8ca6f80779756b94528ddde3
  propFirstElementIsZero1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
fec300c86b9bda28e1ac4a9d98d0cb40
  propILowerThanKLessThanOrEqualToZero ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(S),1*U(U)><S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 Main.$wpropILowerThanKLessThanOrEqualToZero ww1 ww3 } }) -}
b9b2c3a9baaf41e6dc6dc99cba3aad50
  propList2Equal :: GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.gtInteger# n Main.$s^2 of wild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case Main.$wgrow
                             @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                             (\ (ds :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                              case ds of wild1 { (,) x y ->
                              case GHC.Integer.Type.leInteger#
                                     (GHC.Integer.Type.plusInteger x y)
                                     n of wild2 {
                                DEFAULT
                                -> GHC.Types.[]
                                     @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                1#
                                -> GHC.Types.:
                                     @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                     (GHC.Integer.Type.plusInteger x y, y)
                                     (GHC.Types.:
                                        @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                        (x, GHC.Integer.Type.plusInteger x y)
                                        (GHC.Types.[]
                                           @ (GHC.Integer.Type.Integer,
                                              GHC.Integer.Type.Integer))) } })
                             Main.propList2Equal3 of ww { (#,#) ww1 ww2 ->
                      GHC.Classes.$fEq[]_$c==
                        @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                        Main.$s$fEq(,)1
                        (Data.OldList.sortBy
                           @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                           Main.propList2Equal2
                           (GHC.Types.:
                              @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                              ww1
                              (Main.propList2Equal1
                                 @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                 ww2)))
                        (Data.OldList.sortBy
                           @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                           Main.propList2Equal2
                           (Main.$wstep1list
                              @ GHC.Integer.Type.Integer
                              @ GHC.Integer.Type.Integer
                              n
                              Main.propList2Equal3)) } }) -}
18a54383fe6be5923b515e632ec34633
  propList2Equal1 :: [Main.Tree a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
23a7447a1bb48642ba3ddd9997d1aa1b
  propList2Equal2 ::
    (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
                   (w1 :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 -> Main.$wlvl2 ww1 ww2 ww4 ww5 } }) -}
89249e46842d963f20b1134499a292ff
  propList2Equal3 ::
    (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Main.coprime1, Main.coprime1)) -}
dfdf0c4246e48f74b8d32647855326f8
  propListEqual :: GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (n :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.gtInteger# n Main.$s^2 of wild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case Main.$wgrow
                             @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                             (\ (ds :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                              case ds of wild1 { (,) x y ->
                              case GHC.Integer.Type.leInteger#
                                     (GHC.Integer.Type.plusInteger x y)
                                     n of wild2 {
                                DEFAULT
                                -> GHC.Types.[]
                                     @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                1#
                                -> GHC.Types.:
                                     @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                     (GHC.Integer.Type.plusInteger x y, x)
                                     (GHC.Types.:
                                        @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                        (x, GHC.Integer.Type.plusInteger x y)
                                        (GHC.Types.[]
                                           @ (GHC.Integer.Type.Integer,
                                              GHC.Integer.Type.Integer))) } })
                             Main.propList2Equal3 of ww { (#,#) ww1 ww2 ->
                      GHC.Classes.$fEq[]_$c==
                        @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                        Main.$s$fEq(,)1
                        (Data.OldList.sortBy
                           @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                           Main.propList2Equal2
                           (GHC.Types.:
                              @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                              ww1
                              (Main.propList2Equal1
                                 @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                                 ww2)))
                        (Data.OldList.sortBy
                           @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                           Main.propList2Equal2
                           (Main.$wstep1list
                              @ GHC.Integer.Type.Integer
                              @ GHC.Integer.Type.Integer
                              n
                              Main.propList2Equal3)) } }) -}
aa01f46e1972b760155b95f82abcfe31
  propMinimalAmountOfPairsWithDifferentElements ::
    [GHC.Types.Int]
    -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (x :: [GHC.Types.Int])
                   (y :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int x 0# of ww2 { DEFAULT ->
                 case GHC.Prim.>=# ww2 2# of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> case Main.$wgo y 0# of ww { DEFAULT ->
                      case GHC.Prim.<# ww ww2 of lwild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case (Main.isLinear1 x y)
                                  `cast`
                                (Data.Semigroup.Internal.N:All[0]) of wild {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } } } }) -}
20722be3de6eb009698448adbed85e7d
  propRelationsBetweenDifferentElements ::
    [GHC.Types.Int]
    -> [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>,
     Unfolding: (\ (x :: [GHC.Types.Int])
                   (y :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int x 0# of ww2 { DEFAULT ->
                 case GHC.Prim.>=# ww2 2# of lwild {
                   DEFAULT -> GHC.Types.True
                   1#
                   -> let {
                        $j :: GHC.Types.Bool <join 0>
                        = case (Main.isLinear1 x y)
                                 `cast`
                               (Data.Semigroup.Internal.N:All[0]) of wild {
                            GHC.Types.False -> GHC.Types.True
                            GHC.Types.True -> GHC.Types.False }
                      } in
                      letrec {
                        go :: [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Types.Bool
                          <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(GHC.Types.Int, GHC.Types.Int)]) ->
                          case ds of wild {
                            [] -> $j
                            : y1 ys
                            -> case y1 of wild1 { (,) x1 ds1 ->
                               case x1 of wild2 { GHC.Types.I# x2 ->
                               case ds1 of wild3 { GHC.Types.I# y2 ->
                               case GHC.Prim.==# x2 y2 of lwild1 {
                                 DEFAULT -> GHC.Types.True 1# -> go ys } } } } }
                      } in
                      go y } }) -}
28e511c4d49f336b53b3c6c4bfc2aad8
  propStepCoprimeContainsAllCoprimes ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><L,A>, Inline: [0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer) ->
                 Main.$wpropStepCoprimeContainsAllCoprimes w) -}
915bc8db52dcd9a9bc186d5bfa7a2119
  step1 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> (a, a) -> [(a, a)]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (w3 :: (a, a)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 Main.$wstep1 @ a w w1 w2 ww1 ww2 }) -}
feeeeed6d99f43a37abd2ad5264b962e
  step1list ::
    GHC.Integer.Type.Integer
    -> (a, b) -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Arity: 2, Strictness: <S,U><S,1*H>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (w :: GHC.Integer.Type.Integer) (w1 :: (a, b)) ->
                 case w1 of w2 { (,) ipv ipv1 -> Main.$wstep1list @ a @ b w w2 }) -}
d6e1e2086db3afcfa7d08255a0a86a26
  step2 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> (a, a) -> [(a, a)]
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,A)><L,U><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Num.Num a)
                   (w2 :: a)
                   (w3 :: (a, a)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 Main.$wstep2 @ a w w1 w2 ww1 ww2 }) -}
08d7862129df8f8003fa41d59a4f0c48
  stepCoprime ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
    -> [(GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)]
  {- Arity: 3, Strictness: <S,U><L,A><S(SS),1*U(U,U)>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Integer.Type.Integer)
                   (w1 :: GHC.Integer.Type.Integer)
                   (w2 :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)) ->
                 case w2 of ww { (,) ww1 ww2 -> Main.$wstepCoprime w ww1 ww2 }) -}
51e2d1681bd1699f571412384ef42f3f
  tree ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer
    -> Main.Tree (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- Arity: 2, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Integer.Type.Integer)
                   (m :: GHC.Integer.Type.Integer) ->
                 Main.grow
                   @ (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
                   (Main.stepCoprime n m)
                   Main.propList2Equal3) -}
015ea8c16def3d4b4e707d3ac697633a
  tree1 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> Main.Tree (a, a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: GHC.Num.Num a) (w2 :: a) ->
                 case Main.$wtree1 @ a w w1 w2 of ww { (#,#) ww1 ww2 ->
                 Main.T @ (a, a) ww1 ww2 }) -}
f4e1f3ebac7428db7aca781e1ba4ee2e
  tree2 ::
    (GHC.Classes.Ord a, GHC.Num.Num a) => a -> Main.Tree (a, a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)><L,U(C(C1(U)),A,A,A,A,A,C(U))><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Classes.Ord a) (w1 :: GHC.Num.Num a) (w2 :: a) ->
                 case Main.$wtree2 @ a w w1 w2 of ww { (#,#) ww1 ww2 ->
                 Main.T @ (a, a) ww1 ww2 }) -}
d8a360430017796a796c42e6f3f65c2f
  tree2list :: Main.Tree a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m2,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Main.Tree a) ->
                 case w of ww { Main.T ww1 ww2 ->
                 GHC.Types.: @ a ww1 (Main.propList2Equal1 @ a ww2) }) -}
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.ChanceDouble]
  = Main.$fArbitraryChanceDouble
instance [safe] GHC.Classes.Eq [Main.ChanceDouble]
  = Main.$fEqChanceDouble
instance [safe] GHC.Classes.Eq [Main.Tree] = Main.$fEqTree
instance [safe] GHC.Classes.Ord [Main.ChanceDouble]
  = Main.$fOrdChanceDouble
instance [safe] GHC.Classes.Ord [Main.Tree] = Main.$fOrdTree
instance [safe] GHC.Read.Read [Main.ChanceDouble]
  = Main.$fReadChanceDouble
instance [safe] GHC.Show.Show [Main.ChanceDouble]
  = Main.$fShowChanceDouble
instance [safe] GHC.Show.Show [Main.Tree] = Main.$fShowTree
"SPEC/Main $fArbitraryZipList2 @ Int" [orphan] [0] forall (w :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                  GHC.Types.Int)
  Test.QuickCheck.Arbitrary.$fArbitraryZipList2 @ GHC.Types.Int w
  = Main.$s$fArbitraryZipList1
"SPEC/Main $fEq(,) @ Int @ Int" [orphan] forall (v1 :: GHC.Classes.Eq
                                                         GHC.Types.Int)
                                                (v :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int v v1
  = Main.$s$fEq(,)
"SPEC/Main $fEq(,) @ Integer @ Integer" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                 GHC.Integer.Type.Integer)
                                                        (v :: GHC.Classes.Eq
                                                                GHC.Integer.Type.Integer)
  GHC.Classes.$fEq(,) @ GHC.Integer.Type.Integer
                      @ GHC.Integer.Type.Integer
                      v
                      v1
  = Main.$s$fEq(,)1
"SPEC/Main $fEq(,)_$c/= @ Int @ Int" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                 GHC.Types.Int)
                                                     ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Main.$s$fEq(,)_$s$fEq(,)_$c/=
"SPEC/Main $fEq(,)_$c/= @ Integer @ Integer" [orphan] forall ($dEq1 :: GHC.Classes.Eq
                                                                         GHC.Integer.Type.Integer)
                                                             ($dEq :: GHC.Classes.Eq
                                                                        GHC.Integer.Type.Integer)
  GHC.Classes.$fEq(,)_$c/= @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           $dEq
                           $dEq1
  = Main.$s$fEq(,)_$s$fEq(,)_$c/=1
"SPEC/Main $fShow[] @ (Int, Int)" [orphan] forall (v :: GHC.Show.Show
                                                          (GHC.Types.Int, GHC.Types.Int))
  GHC.Show.$fShow[] @ (GHC.Types.Int, GHC.Types.Int) v
  = Main.$s$fShow[]
"SPEC/Main $fShow[]_$cshow @ (Int, Int)" [orphan] forall ($dShow :: GHC.Show.Show
                                                                      (GHC.Types.Int,
                                                                       GHC.Types.Int))
  GHC.Show.$fShow[]_$cshow @ (GHC.Types.Int, GHC.Types.Int) $dShow
  = Main.$s$fShow[]_$cshow
"SPEC/Main $fShow[]_$cshowList @ (Int, Int)" [orphan] forall ($dShow :: GHC.Show.Show
                                                                          (GHC.Types.Int,
                                                                           GHC.Types.Int))
  GHC.Show.$fShow[]_$cshowList @ (GHC.Types.Int, GHC.Types.Int)
                               $dShow
  = Main.$s$fShow[]_$cshowList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

